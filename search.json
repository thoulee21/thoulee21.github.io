[{"title":"Cobbler Deployment Practice","url":"/2025/04/24/cobbler-deploy/","content":"\n# 部署 [Cobbler](http://cobbler.github.io/) 2.8.5\n\n## Cobbler 简介\n\n### Cobbler 作用\nCobbler是Linux安装服务器可以快速设置网络安装环境、具备web管理界面\n\n### ISO文件归档下载\n- https://mirrors.aliyun.com/centos-vault\n- http://dl.rockylinux.org/vault/rocky\n\n\n## 部署前准备\n\n> 文章以CentOS7.9部署V2.8.5版本为例进行示范\n\n### cobbler2.8.5已经验证能够部署的系统\n- rhel6系列（已经验证OK）\n- rhel7系列（已经验证OK）\n- rhel8系列（已经验证OK）\n- rhel9系列（镜像文件是没有问题的，但是安装的时候会有报错，目前还未解决）\n\n#### YUM源准备（必须有epel和Base源）\n```shell\nbash <(curl -sSL https://linuxmirrors.cn/main.sh)\n```\n\n#### 关闭防火墙和SELinux\n```shell\nsystemctl disable firewalld.service\nsystemctl stop firewalld.service\nsed -i 's/^SELINUX=.*/SELINUX=disabled/g' /etc/selinux/config\n\n#关闭了selinux需要重启服务器生效\nreboot\n```\n\n## Cobbler 部署\n\n### Cobbler 组件安装\n\n```shell\n#Centos7（其余的软件会作为依赖安装）\nyum install -y dhcp tftp-server xinetd debmirror pykickstart cobbler cobbler-web  \n```\n\n### 组件作用简介\n- cobbler     #基础组件\n- cobbler-web #web组件\n- debmirror   #镜像管理工具\n- pykickstart #检查cobbler配置文件语法\n- httpd       #发布镜像\n- syslinux    #配置引导文件（生成pxelinux.0）\n- tftp-server #为PXE的客户端提供引导文件\n- dhcp        #为PXE的客户端提供IP地址、告知tftp的服务地址\n\n### Cobbler 目录文件简介\n\n```shell\nrpm -ql cobbler\n```\n\n#### Cobbler 目录文件结构\n\n| 目录/文件路径                   | 说明                            |\n| ------------------------------- | ------------------------------- |\n| `/etc/cobbler`                  | 配置文件目录                    |\n| `/etc/cobbler/settings`         | cobbler主配置文件               |\n| `/etc/cobbler/dhcp.template`    | dhcp服务的配置模板              |\n| `/etc/cobbler/tftpd.template`   | tftp服务的配置模板              |\n| `/etc/cobbler/rsync.template`   | rsync服务的配置模板             |\n| `/etc/cobbler/iso`              | iso模板配置文件目录             |\n| `/etc/cobbler/pxe`              | pxe模板文件目录                 |\n| `/etc/cobbler/power`            | 电源的配置文件目录              |\n| `/etc/cobbler/users.conf`       | web服务授权配置文件             |\n| `/etc/cobbler/users.digest`     | 用于web访问的用户名密码配置文件 |\n| `/etc/cobbler/dnsmasq.template` | dns服务的配置模板               |\n| `/etc/cobbler/modules.conf`     | cobbler模块配置文件             |\n| `/var/lib/cobbler`              | cobbler数据目录                 |\n| `/var/lib/cobbler/config`       | 配置文件                        |\n| `/var/lib/cobbler/kickstarts`   | 默认存放kickstart文件           |\n| `/var/lib/cobbler/loaders`      | 存放的各种引导程序              |\n| `/var/www/cobbler`              | 系统安装镜像目录                |\n| `/var/www/cobbler/ks_mirror`    | 导入的系统镜像列表              |\n| `/var/www/cobbler/images`       | 导入的系统镜像启动文件          |\n| `/var/www/cobbler/repo_mirror`  | YUM源存储目录                   |\n| `/var/log/cobbler`              | 日志目录                        |\n| `/var/log/cobbler/install.log`  | 客户端系统安装日志              |\n| `/var/log/cobbler/cobbler.log`  | cobbler日志                     |\n\n---\n\n### Cobbler 主配置文件修改\n\n```shell\n#生成密文密码\nopenssl passwd -1\n\n#设置root密码\nsed -i 's|^default_password_crypted.*|default_password_crypted: \"$1$Nrt/tXCR$BrRthh4tFphGyCunrGWzi/\"|g' /etc/cobbler/settings\n\n#设置指定tftp服务IP地址\nsed -i 's|^next_server.*|next_server: 192.168.200.10|g' /etc/cobbler/settings\n\n#设置cobbler服务地址\nsed -i 's|^server.*|server: 192.168.200.10|g' /etc/cobbler/settings\n\n#cobbler接管dhcp（0为关闭 1为开启）\nsed -i 's|^manage_dhcp.*|manage_dhcp: 0|g' /etc/cobbler/settings\n\n#cobbler接管tftp（0为关闭 1为开启）\nsed -i 's|^manage_tftpd.*|manage_tftpd: 1|g' /etc/cobbler/settings\n      \n#cobbler启动服务\nsystemctl enable --now httpd.service\nsystemctl enable --now cobblerd.service\n```\n> cobbler可以将自身作为dhcp服务器为安装系统的客户端分发IP地址、也可以使用已有的dhcp服务器，为了首次同步成功这里统一将cobbler接管dhcp的功能暂时关闭\n\n### Cobbler 首次检查\n\n> 可能每人的报错问题不同此处列举我的报错问题\n```shell\ncobbler check\n```\n\n```\n1 : change 'disable' to 'no' in /etc/xinetd.d/tftp\n2 : Some network boot-loaders are missing from /var/lib/cobbler/loaders, you may run 'cobbler get-loaders' to download them, or, if you only want to handle x86/x86_64 netbooting, you may ensure that you have installed a *recent* version of the syslinux package installed and can ignore this message entirely.  Files in this directory, should you want to support all architectures, should include pxelinux.0, menu.c32, elilo.efi, and yaboot. The 'cobbler get-loaders' command is the easiest way to resolve these requirements. #可以忽略（确保系统已经安装pxelinux）\n3 : enable and start rsyncd.service with systemctl\n4 : comment out 'dists' on /etc/debmirror.conf for proper debian support\n5 : comment out 'arches' on /etc/debmirror.conf for proper debian support\n6 : fencing tools were not found, and are required to use the (optional) power management features. install cman or fence-agents to use them #可以忽略\n```\n\n### 解决 Cobbler 检查报错\n\n```shell\n#报错1问题解决\ncat << EOF | tee /etc/xinetd.d/tftp\nservice tftp\n{\n        socket_type             = dgram\n        protocol                = udp\n        wait                    = yes \n        user                    = root\n        server                  = /usr/sbin/in.tftpd\n        server_args             = -s /var/lib/tftpboot\n        disable                 = no\n        per_source              = 11\n        cps                     = 100 2\n        flags                   = IPv4\n}\nEOF\n\n#报错3问题解决\nsystemctl enable --now rsyncd.service\n\n#报错4、5问题解决\nsed -i 's|@dists=.*|# @dists=|' /etc/debmirror.conf \nsed -i 's|@arches=.*|# @arches=|' /etc/debmirror.conf\n```\n\n### Cobbler 首次同步\n\n```shell\n#再次运行检查\ncobbler check\n```\n\n```\n1 : Some network boot-loaders are missing from /var/lib/cobbler/loaders, you may run 'cobbler get-loaders' to download them, or, if you only want to handle x86/x86_64 netbooting, you may ensure that you have installed a *recent* version of the syslinux package installed and can ignore this message entirely.  Files in this directory, should you want to support all architectures, should include pxelinux.0, menu.c32, elilo.efi, and yaboot. The 'cobbler get-loaders' command is the easiest way to resolve these requirements.\n2 : fencing tools were not found, and are required to use the (optional) power management features. install cman or fence-agents to use them \n```\n\n```shell\n#cobbler首次同步\ncobbler sync\n```\n\n## 配置 DHCP 服务\n\n### Cobbler 接管 DHCP\n\n```shell\n#修改dhcp模板文件\nvim /etc/cobbler/dhcp.template  \n```\n\n```\nsubnet 192.168.200.0 netmask 255.255.255.0 {\n     option routers             192.168.200.2;\n     option domain-name-servers 223.5.5.5;\n     option subnet-mask         255.255.225.0;\n     range dynamic-bootp        192.168.200.200 192.168.200.250;\n     default-lease-time         7200;\n     max-lease-time             7200;\n     next-server                $next_server;   \n     class \"pxeclients\" {\n          match if substring (option vendor-class-identifier, 0, 9) = \"PXEClient\";\n          if option pxe-system-type = 00:02 {\n                  filename \"ia64/elilo.efi\";\n          } else if option pxe-system-type = 00:06 {\n                  filename \"grub/grub-x86.efi\";\n          } else if option pxe-system-type = 00:07 {\n                  filename \"grub/grub-x86_64.efi\";\n          } else if option pxe-system-type = 00:09 {\n                  filename \"grub/grub-x86_64.efi\";\n          } else {\n                  filename \"pxelinux.0\";\n          }\n     }\n    #option dhcp-server-identifier 192.168.200.2;  #生产内现有的DHCP服务器\n}\n```\n\n```shell\n#cobbler主配置文件开启dhcp接管\nsed -i 's|^manage_dhcp.*|manage_dhcp: 1|g' /etc/cobbler/settings \n\n#重新同步\nsystemctl restart cobblerd.service\ncobbler sync  \n\n#启动dhcp服务\nsystemctl enable --now dhcpd.service \nsystemctl restart dhcpd.service\n```\n\n### 使用现有 DHCP 服务器\n\n```shell\n#修改dhcp配置文件\nvim /etc/dhcp/dhcpd.conf \n```\n\n```\nsubnet 192.168.200.0 netmask 255.255.225.0 {\n     option routers             192.168.200.2;\n     option domain-name-servers 223.5.5.5;\n     option subnet-mask         255.255.225.0;\n     range dynamic-bootp        192.168.200.2 192.168.200.200;\n     default-lease-time         600;\n     next-server 192.168.200.10;  #指定cobbler服务器为tftp服务器\n     filename \"pxelinux.0\";       #指定启动文件名称\n     max-lease-time 7200;\n}\n```\n\n```shell\n#启动dhcp服务\nsystemctl enable --now dhcpd.service \nsystemctl restart dhcpd.service\n```\n\n## 其他相关服务配置\n\n### 配置 TFTP 服务\n\n```shell\n#确保tftp的站点目录存在引导文件（cobbler检查问题的过程中已经修了tftp的配置文件）\nll /var/lib/tftpboot/\n```\n```\ndrwxr-xr-x  3 root root   4096 Mar  1 23:54 boot\ndrwxr-xr-x. 2 root root   4096 Oct 15  2019 etc\ndrwxr-xr-x. 2 root root   4096 Mar  1 23:54 grub  #UEFI启动菜单目录\ndrwxr-xr-x. 7 root root   4096 Mar  1 23:54 images\ndrwxr-xr-x. 2 root root   4096 Oct 15  2019 images2\n-rw-r--r--. 2 root root  26140 Oct 31  2018 memdisk\n-rw-r--r--. 2 root root  54964 Mar  1 23:54 menu.c32\ndrwxr-xr-x. 2 root root   4096 Oct 15  2019 ppc\n-rw-r--r--. 2 root root  16794 Mar  1 23:54 pxelinux.0\ndrwxr-xr-x. 2 root root   4096 Mar  1 23:56 pxelinux.cfg #BIOS启动菜单目录\ndrwxr-xr-x. 2 root root   4096 Mar  1 23:54 s390x\n-rw-r--r--  2 root root 198236 Feb  8 15:17 yaboot\n```\n\n```shell\n#启动tftp服务\nsystemctl enable --now tftp.service  \nsystemctl enable --now xinetd.service\nsystemctl restart tftp.service \nsystemctl restart xinetd.service\n```\n\n### 客户端测试访问\n\n![客户端测试访问](http://pic.swireb.cn/images/image-20210301152228267.png)\n\n### 系统镜像挂载\n\n#### Ubuntu镜像注意事项\n不支持desktop、live版本（仅支持LTS server version版本）<br/>\n推荐ubuntu-18.04-server-amd64\n\n#### 使用光驱加载Centos7的系统镜像\n\n```shell\n#为后续cobble导入镜像做准备\nmount -t iso9660 -o loop,ro /dev/cdrom /mnt\n```\n\n## Cobbler 使用\n\n### Cobbler 命令语法\n\n```shell\n#命令语法\ncobbler --help\ncobbler <distro|profile|system|repo|image|mgmtclass|package|file> ... \n        [add|edit|copy|getks*|list|remove|rename|report] [options|--help]\ncobbler <aclsetup|buildiso|import|list|replicate|report|reposync|sync|validateks|version|signature|get-loaders|hardlink> [options|--help]\n```\n\n### Cobbler 导入镜像\n\n#### 命令语法\n```shell\ncobbler import --help\n```\n\n```\nUsage: cobbler import [options]\nOptions:\n  --arch=ARCH           镜像架构\n  --path=PATH           镜像导入路径\n  --name=NAME           镜像名称\n```\n\n```shell\n#命令操作\ncobbler import --name=CentOS7.9 --path=/mnt\ncobbler import --name=Rocky8.4 --path=/mnt\ncobbler import --name=Rocky8.5 --path=/mnt\ncobbler import --name=Rocky8.6 --path=/mnt\ncobbler import --name=Rocky8.7 --path=/mnt\ncobbler import --name=Rocky8.8 --path=/mnt\n\n#注意cobbler2.8.5导入rhel9系列的镜像文件是没有问题的，但是安装的时候会有报错（目前还未解决）\n\n#列出对象\ncobbler distro list\ncobbler profile list\n\n#列出对象详细信息\ncobbler distro report --name=CentOS7.9-x86_64\n```\n\n#### 导入镜像的过程\n将光盘文件复制到`/var/www/cobbler/ks_mirror`目录下\n并且自动生成apache的一个子配置文件`/etc/httpd/conf.d/cobbler.conf`将镜像发布出去\n`http://IP/cobbler/`\n\n导入Cent0S6和CentOS7导入无异常\n导入CentOS8的镜像会报错解决办法在文章下方cobbler导入镜像失败\n导入Ubuntu 18.04之后的版本也是导入失败（非LTS版本可能支持的不友好）\n\n### CentOS 系统 KS 模板文件\n\n```shell\n#备份默认ks\nmv /var/lib/cobbler/kickstarts/sample_end.ks /var/lib/cobbler/kickstarts/sample_end.ks.bak\n\n#适配RHEL系列\ncurl -L https://drive.swireb.cn/d/Linux/Cobbler/v2.8.5/ks/sample_end.ks > /var/lib/cobbler/kickstarts/sample_end.ks\n```\n\n[磁盘分区方案](http://www.hellokvm.com/?p=476)\n\n### Ubuntu 系统 KS 模板文件\n\n```shell\n#备份默认ks\nmv /var/lib/cobbler/kickstarts/sample.seed /var/lib/cobbler/kickstarts/sample.seed.bak\n\n#适配Ubuntu18.04其余版本\ncurl -L https://drive.swireb.cn/d/Linux/Cobbler/v2.8.5/ks/sample.seed > /var/lib/cobbler/kickstarts/sample.seed\n```\n\n#### Ubuntu系统配置软件源模板文件\n```shell\nvim /var/lib/cobbler/snippets/late_apt_repo_config\n```\n\n```shell\ncat >/etc/apt/sources.list<<EOF\ndeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\nEOF\n```\n\n#### 允许 root 用户 SSH 登录\n```shell\nsed -i 's|.*PermitRootLogin.*|PermitRootLogin yes|g' /etc/ssh/sshd_config && service ssh start\n```\n\n#### 安装Ubuntu系统之后执行的脚本模板文件\n```shell\nvim /var/lib/cobbler/scripts/preseed_late_default\n```\n```shell\n$SNIPPET('post_run_deb')\n```\n\n## Cobbler 配置启动菜单\n\n### 客户端配置\n\n![客户端配置](http://pic.swireb.cn/images/image-20210302000400700.png)\n\n### 服务端配置 BIOS 启动菜单\n\n#### 修改启动菜单配置文件\n```shell\nvim /etc/cobbler/pxe/pxedefault.template\n```\n```\n#LABEL local\n#        MENU LABEL (local)\n#        MENU DEFAULT\n#        LOCALBOOT -1\n```\n\n```shell\n#cobbler重新同步\ncobbler sync\n```\n\n### 服务端配置 UEFI 启动菜单\n\n```shell\n#手动下载UEFI启动的相关文件\nwget https://drive.swireb.cn/d/Linux/Cobbler/v2.8.5/grub.tar.gz\n\ntar xf grub.tar.gz -C /var/lib/cobbler/loaders\n\n#命令下载UEFI启动的相关文件（V2.8.5版本此命令已经失效）\ncobbler get-loaders\n```\n\n#### 修改启动菜单配置文件\n```shell\nvim /etc/cobbler/pxe/efidefault.template\n```\n```\ntimeout=6000  #修改启动菜单加时间（必须修改不然一闪则过）\n```\n\n#### cobbler 重新同步\n```shell\ncobbler sync\n```\n\n## Cobbler 配置 Web 管理界面\n\n### 访问地址（必须为*https*）\nhttps://ip/cobbler_web\n\n### 默认访问用户\n- 用户: cobbler\n- 密码: cobbler\n\n### 创建用户\n```\n/etc/cobbler/users.conf       #web服务授权配置文件\n/etc/cobbler/users.digest     #用于web访问的用户名密码配置文件\n```\n\n![Cobbler Web界面](http://pic.swireb.cn/images/image-20210302002442859.png)\n\n## Cobbler 导入镜像失败\n\n### 故障示意图\n\n![故障示意图](http://pic.swireb.cn/images/image-20210302150753759.png)\n\n### 主要还是应为签名文件中不包括导入的系统镜像\n\n```shell\n#更新签名文件\ncobbler signature report #列出\ncobbler signature update #更新\n\n#直接下载签名文件\ncurl -L https://cobbler.github.io/signatures/2.8.x/latest.json > /var/lib/cobbler/distro_signatures.json\n```\n\n### CentOS-Stream 解决办法\n\n```shell\n#在rhel8的version_file键值对中添加centos-linux-release centos-stream-release\nvim /var/lib/cobbler/distro_signatures.json\n```\n\n```json\n\"rhel8\": {\n    \"signatures\":[\"BaseOS\"],\n    \"version_file\":\"(redhat|sl|slf|centos|centos-linux|centos-stream|oraclelinux|vzlinux)-release-(?!notes)([\\\\w]*-)*8(Server)*[\\\\.-]+(.*)\\\\.rpm\",\n    \"version_file_regex\":null,\n    \"kernel_arch\":\"kernel-(.*).rpm\",\n    \"kernel_arch_regex\":null,\n    \"supported_arches\":[\"aarch64\",\"i386\",\"x86_64\",\"ppc64le\"],\n    \"supported_repo_breeds\":[\"rsync\", \"rhn\", \"yum\"],\n    \"kernel_file\":\"vmlinuz(.*)\",\n    \"initrd_file\":\"initrd(.*)\\\\.img\",\n    \"isolinux_ok\":false,\n    \"default_kickstart\":\"/var/lib/cobbler/kickstarts/sample_end.ks\",\n    \"kernel_options\":\"\",\n    \"kernel_options_post\":\"\",\n    \"boot_files\":[]\n},\n```\n\n```shell\n#重启服务\nsystemctl restart cobblerd.service\n```\n\n---\n\n### Ubuntu18、Ubuntu19 解决办法\n\n#### Ubuntu 18.10\n```json\n\"cosmic\": {\n    \"signatures\":[\"dists\", \".disk\"],\n    \"version_file\":\"Release|mini-info\",\n    \"version_file_regex\":\"Codename: cosmic|Ubuntu 18.10\",\n    \"kernel_arch\":\"linux-headers-(.*)\\\\.deb\",\n    \"kernel_arch_regex\":null,\n    \"supported_arches\":[\"i386\",\"amd64\"],\n    \"supported_repo_breeds\":[\"apt\"],\n    \"kernel_file\":\"linux(.*)\",\n    \"initrd_file\":\"initrd(.*)\\\\.gz\",\n    \"isolinux_ok\":false,\n    \"default_kickstart\":\"/var/lib/cobbler/kickstarts/sample.seed\",\n    \"kernel_options\":\"\",\n    \"kernel_options_post\":\"\",\n    \"boot_files\":[]\n},\n```\n\n#### Ubuntu 19.04\n```json\n\"disco\": {\n    \"signatures\":[\"dists\", \".disk\"],\n    \"version_file\":\"Release|mini-info\",\n    \"version_file_regex\":\"Codename: disco|Ubuntu 19.04\",\n    \"kernel_arch\":\"linux-headers-(.*)\\\\.deb\",\n    \"kernel_arch_regex\":null,\n    \"supported_arches\":[\"i386\",\"amd64\"],\n    \"supported_repo_breeds\":[\"apt\"],\n    \"kernel_file\":\"linux(.*)\",\n    \"initrd_file\":\"initrd(.*)\\\\.gz\",\n    \"isolinux_ok\":false,\n    \"default_kickstart\":\"/var/lib/cobbler/kickstarts/sample.seed\",\n    \"kernel_options\":\"\",\n    \"kernel_options_post\":\"\",\n    \"boot_files\":[]\n}，\n```\n\n#### Ubuntu 19.10\n```json\n\"eoan\": {\n    \"signatures\":[\"dists\", \".disk\"],\n    \"version_file\":\"Release|mini-info\",\n    \"version_file_regex\":\"Codename: eoan|Ubuntu 19.10\",\n    \"kernel_arch\":\"linux-headers-(.*)\\\\.deb\",\n    \"kernel_arch_regex\":null,\n    \"supported_arches\":[\"i386\",\"amd64\"],\n    \"supported_repo_breeds\":[\"apt\"],\n    \"kernel_file\":\"linux(.*)\",\n    \"initrd_file\":\"initrd(.*)\\\\.gz\",\n    \"isolinux_ok\":false,\n    \"default_kickstart\":\"/var/lib/cobbler/kickstarts/sample.seed\",\n    \"kernel_options\":\"\",\n    \"kernel_options_post\":\"\",\n    \"boot_files\":[]\n},\n```\n\n##### 重启服务\n```shell\nsystemctl restart cobblerd.service\n```\n","tags":["cobbler","centos","linux"]},{"title":"医疗器械行业软件测试面试解析","url":"/2025/04/03/interviews/med/","content":"\n# Job Description\n## 岗位职责\n1. 负责产品软件测试\n2. 负责日常用户需求沟通、需求捕获、需求确认回访等工作、承担产品、项目的需求分析工作，编写需求方案及需求规格说明书等文档\n3. 与开发、测试团队对接，参与软件方案设计\n4. 参与需求验证的工作以及需求分析\n5. 负责生化或者发光的产品性能测试，熟悉生化发光仪器的行业或者企业标准的优先\n6. 负责产品的用户手册等资料的编写，演示和培训工作\n\n## 任职资格\n1. 本科及以上、通过CET-4\n2. 熟悉ISO14971、9706.1或60601-1，熟悉YY0505及相关产品的行业标准优先录取\n3. 有编写和维护测试用例的经验\n4. 有使用实验室仪器的经验\n\n### 针对该岗位的职责与任职资格分析如下：\n\n---\n\n#### **一、岗位职责解析**\n1. **产品软件测试**  \n   • 需根据需求文档设计测试用例，覆盖功能、性能、安全等测试场景，执行手动/自动化测试并跟踪缺陷修复。  \n   • 涉及生化或发光仪器的性能测试时，需熟悉行业标准（如YY/T 0654等），并搭建符合医疗设备要求的测试环境。\n\n2. **需求沟通与分析**  \n   • 需与产品、开发团队协作，明确需求边界，编写需求规格说明书，并参与方案设计评审，确保需求可测试性。  \n   • 需求验证需结合测试用例执行结果，确保产品功能与用户需求一致。\n\n3. **文档编写与培训**  \n   • 用户手册需包含操作流程、故障处理等内容，并符合医疗器械注册文档规范（如ISO 13485）。  \n   • 需具备产品演示能力，向客户或内部团队提供技术培训。\n\n4. **行业标准与合规性**  \n   • 熟悉ISO 14971（风险管理）、YY 0505（医用电气设备电磁兼容性）等标准，确保产品符合医疗器械法规要求。\n\n---\n\n#### **二、任职资格匹配建议**\n1. **学历与语言能力**  \n   • 本科及以上学历（优先计算机、生物医学工程等专业），需通过CET-4，能够阅读英文技术文档。\n\n2. **技能与经验**  \n   • **测试能力**：需掌握测试用例设计方法（如等价类划分、边界值分析），熟练使用测试工具（如Jira、Postman、Jmeter）。  \n   • **行业知识**：熟悉生化/发光仪器工作原理（如化学发光免疫分析、光路系统校准），了解企业标准（如《全自动化学发光免疫分析仪》行业标准）。  \n   • **实验室经验**：有使用分光光度计、酶标仪等实验室仪器的实操经验者优先。\n\n3. **软性要求**  \n   • 需具备跨部门沟通能力，能够协调开发、测试、市场团队，推动问题解决。  \n   • 注重细节，熟悉医疗设备开发全生命周期管理（如需求变更控制、风险分析）。\n\n---\n\n#### **三、岗位竞争力提升方向**\n• **技术拓展**：学习自动化测试框架（如Selenium、Appium）和性能测试工具（如LoadRunner），提升测试效率。  \n• **行业认证**：考取ISTQB（国际软件测试资格认证）或医疗器械质量管理体系内审员资质。  \n• **标准深化**：深入研究IEC 60601-1（医用电气设备安全通用要求）和ISO 62304（医疗器械软件生命周期流程）。\n\n---\n\n### 总结\n该岗位要求综合技术能力（测试、需求分析）、行业知识（医疗设备标准）和文档管理经验，适合具备医疗器械测试背景或有意向深耕IVD（体外诊断）领域的候选人。建议候选人强化自动化测试技能，并熟悉医疗产品注册流程以提升适配性\n\n# 医疗器械行业标准解析\n针对该岗位涉及的医疗器械行业标准，以下从**适用范围、核心要求、测试方法**三个维度进行详细拆解，并结合实际应用场景说明如何落地执行：\n\n---\n\n### **一、医疗器械风险管理标准：ISO 14971**\n#### **1. 适用范围**  \n适用于医疗器械全生命周期（设计、生产、上市后监测）的风险管理，覆盖硬件、软件及系统。\n\n#### **2. 核心要求**  \n• **风险分析**：识别危害（如电气安全失效、软件逻辑错误）、危害场景（如设备在手术中死机）及风险等级（严重度×概率）。  \n• **风险控制**：优先通过设计消除风险（如冗余电路），其次采用防护措施（如熔断器），最后在说明书中标注剩余风险。  \n• **风险文档**：需输出《风险管理计划》《风险分析报告》《剩余风险可接受性声明》。\n\n#### **3. 应用实例**  \n• **测试场景**：在软件测试中需验证风险控制措施有效性（如模拟电源故障时设备是否进入安全模式）。  \n• **文档示例**：需求规格书中需标注“软件升级过程需防止断电导致固件损坏”（参考ISO 14971第7.4条）。\n\n---\n\n### **二、医用电气设备安全标准：IEC 60601-1**\n#### **1. 适用范围**  \n所有医用电气设备（如生化分析仪、监护仪）的电气安全通用要求，包括防电击、机械安全等。\n\n#### **2. 核心测试项**  \n• **漏电流测试**：患者漏电流≤100μA（应用部分接触人体时）。  \n• **接地阻抗测试**：保护接地阻抗≤0.1Ω（确保故障电流有效导出）。  \n• **电介质强度测试**：耐压1500V/60s（初级电路与外壳之间）。  \n\n#### **3. 测试方法**  \n• **工具**：使用安规测试仪（如Fluke 6500）执行耐压、接地、漏电流测试。  \n• **环境**：温度23±5℃，湿度30%~60% RH。  \n• **记录**：需保存原始数据并生成《安规测试报告》，符合IEC 60601-1第10章要求。\n\n---\n\n### **三、电磁兼容性标准：YY 0505（等同IEC 60601-1-2）**\n#### **1. 适用范围**  \n医用电气设备在电磁环境中的抗干扰能力及自身发射限值。\n\n#### **2. 核心测试项**  \n| **测试类型**       | **测试项目**                | **限值示例**                          |\n|--------------------|----------------------------|---------------------------------------|\n| **发射测试**       | 传导骚扰（CE）             | 150kHz~30MHz ≤79dBμV（准峰值）        |\n|                    | 辐射骚扰（RE）             | 30MHz~1GHz ≤40dBμV/m（10m距离）       |\n| **抗扰度测试**     | 静电放电（ESD）            | 接触放电±6kV，空气放电±8kV             |\n|                    | 射频辐射抗扰度（RS）       | 3V/m（80MHz~2.5GHz）                  |\n\n#### **3. 测试方法**  \n• **设备**：在电波暗室中使用信号发生器、频谱分析仪、ESD模拟器等。  \n• **判定标准**：测试中设备功能不得降级（如生化仪测试结果偏差需在±5%内）。  \n• **整改案例**：若辐射超标，可增加屏蔽层或优化PCB布局（参考YY0505附录B）。\n\n---\n\n### **四、体外诊断设备标准：YY/T 0654（全自动生化分析仪）**\n#### **1. 性能要求**  \n• **精密度**：CV（变异系数）≤2%（如葡萄糖浓度测试）。  \n• **线性范围**：在厂商声明范围内，相关系数r≥0.995。  \n• **携带污染率**：≤0.5%（高浓度样本对低浓度样本的影响）。  \n\n#### **2. 测试方法**  \n• **精密度测试**：用同一浓度质控液连续测试20次，计算CV值。  \n• **线性验证**：配置5个梯度浓度样本，拟合线性回归方程。  \n• **携带污染测试**：先测高值样本（如1000U/L），再测低值样本（如10U/L），计算污染率。  \n\n#### **3. 数据记录**  \n需提供原始测试数据、仪器校准记录及《性能验证报告》，符合YY/T 0654第5章要求。\n\n---\n\n### **五、环境试验标准：GB/T 14710（医用电器环境要求）**\n#### **1. 测试项目**  \n• **气候试验**：高温（40℃/48h）、低温（-20℃/24h）、湿热（93%RH/40℃/48h）。  \n• **机械试验**：振动（10Hz~55Hz/0.15mm振幅）、碰撞（峰值加速度100m/s²）。  \n\n#### **2. 判定标准**  \n• **功能检查**：试验后设备需正常开机，关键功能（如发光仪光强输出）偏差≤5%。  \n• **安全检查**：绝缘电阻≥2MΩ（耐压测试后）。\n\n---\n\n### **六、标准落地关键点**\n1. **需求阶段**：在需求规格书（SRS）中引用标准条款（如“软件需符合IEC 62304 Class B要求”）。  \n2. **设计阶段**：通过FMEA（失效模式分析）识别高风险项（如YY0505抗扰度不足导致误诊）。  \n3. **测试阶段**：使用标准要求的测试设备（如用网络分析仪验证YY0505传导发射）。  \n4. **文档管理**：建立标准文件清单（如ISO 14971:2019最新版），定期审查合规性。\n\n---\n\n### **获取标准资源的途径**  \n• **官方渠道**：国家药品监督管理局（NMPA）、全国标准信息公共服务平台。  \n• **行业组织**：CMDE（医疗器械技术审评中心）、IMDRF（国际医疗器械监管机构论坛）。  \n• **培训认证**：参加TÜV莱茵、SGS等机构举办的“医疗器械标准与检测”专题培训。\n\n\n# **测试用例编写与维护快速培训指南**  \n基于行业最佳实践及多篇权威资料（如杨学明课程、知乎指南等），以下从**用例设计、编写规范、维护策略**三个维度系统化讲解，助你高效掌握核心技能：\n\n---\n\n#### **一、测试用例设计：6大核心方法**  \n1. **等价类划分法**  \n   • **适用场景**：输入数据范围明确的功能（如年龄输入框仅允许18-60岁）。  \n   • **操作步骤**：  \n     ◦ 划分有效/无效等价类（如有效类为18-60，无效类为<18或>60）。  \n     ◦ 每个等价类选取1-2个代表值测试（如输入17、18、60、61）。  \n   • **优势**：减少重复用例，覆盖典型场景。  \n\n2. **边界值分析法**  \n   • **适用场景**：数值型输入、循环次数等易在边界出错的场景。  \n   • **关键点**：测试最小值、最大值、边界±1（如字段长度为100时，测试99/100/101字符输入）。  \n\n3. **错误推测法**  \n   • **适用场景**：复杂功能或历史问题较多的模块（如支付失败重试逻辑）。  \n   • **操作步骤**：基于经验设计非常规用例（如连续多次点击提交按钮、网络中断后恢复）。  \n\n4. **场景法**  \n   • **适用场景**：业务流程复杂的系统（如电商订单流程）。  \n   • **设计要点**：模拟用户真实操作路径（如“登录→选商品→支付→取消订单→退款”）。  \n\n5. **正交实验设计法**  \n   • **适用场景**：多参数组合测试（如筛选条件包含价格、品牌、评分）。  \n   • **工具支持**：使用正交表工具（如AllPairs）生成最少用例覆盖最大组合。  \n\n6. **因果图法**  \n   • **适用场景**：输入条件存在逻辑依赖（如“仅当用户勾选协议后才允许注册”）。  \n   • **步骤**：绘制因果图→转换为判定表→生成用例。  \n\n---\n\n#### **二、测试用例编写规范：结构与工具**  \n1. **标准模板要素**  \n   • **必填项**：用例编号（如TC-001）、测试目标、前置条件、测试步骤、预期结果、优先级（P0/P1/P2）。  \n   • **扩展项**：测试数据（如特定账号）、关联需求ID、自动化标记（是/否）。  \n   • **示例**（登录功能）：  \n      | 用例编号       | TC-LOGIN-01                     |\n      |----------------|---------------------------------|\n      | 标题           | 验证无效密码登录失败            |\n      | 前置条件       | 已注册用户test@example.com，密码123456 |\n      | 测试步骤       | 输入test@example.com，密码654321 → 点击登录 |\n      | 预期结果       | 提示“密码错误，请重试”           |\n\n2. **工具选择与协作**  \n   • **管理工具**：TestRail（支持用例版本跟踪）、Jira+Zephyr（敏捷团队集成）。  \n   • **自动化工具**：Pytest（接口用例参数化）、Selenium（Web UI自动化脚本生成）。  \n   • **协作规范**：  \n     ◦ 使用统一模板（如Excel或TestRail自定义字段）。  \n     ◦ 定期交叉评审（每周例会，重点检查边界和异常场景）。  \n\n---\n\n#### **三、测试用例维护策略：5大关键点**  \n1. **定期审查与更新**  \n   • **频率**：每版本迭代前审查一次。  \n   • **重点**：删除过时用例（如旧功能废弃）、补充新需求用例、合并冗余用例（如重复的支付流程测试）。  \n\n2. **版本控制与追踪**  \n   • **方法**：使用Git管理用例文档，标记版本号（如V1.2.3）。  \n   • **记录变更**：在Changelog中说明修改原因（如“新增微信支付验证”）。  \n\n3. **分类与标签体系**  \n   • **分类维度**：按模块（用户管理/订单）、测试类型（功能/性能）、优先级（冒烟/回归）。  \n   • **标签示例**：#安全测试、#边界条件、#高并发场景。  \n\n4. **自动化维护**  \n   • **适用场景**：高频执行的回归用例（如核心业务流程）。  \n   • **技术栈**：Jenkins定时触发自动化脚本 + Allure报告分析失败原因。  \n\n5. **数据驱动与参数化**  \n   • **实践**：将测试数据与脚本分离（如CSV文件存储账号密码组合）。  \n   • **优势**：数据变更无需修改脚本，提升维护效率。  \n\n---\n\n#### **四、高级技巧与避坑指南**  \n1. **风险驱动设计**  \n   • **方法**：基于DFMEA（失效模式分析）识别高风险功能（如医疗设备的断电恢复），针对性设计用例。  \n\n2. **用户体验（UCD）测试**  \n   • **重点**：验证界面交互（如按钮位置是否符合习惯）、错误提示友好性（如“网络超时，请重试”而非系统错误码）。  \n\n3. **常见误区**  \n   • **过度设计**：避免为低频场景编写过多用例（如万年历的闰年判断）。  \n   • **忽略非功能需求**：补充性能（响应时间≤2s）、兼容性（Chrome/Firefox/Safari）测试用例。  \n\n---\n\n#### **五、推荐学习资源**  \n• **书籍**：《Google软件测试之道》《测试架构师修炼之道》。  \n• **课程**：杨学明《测试方案和测试用例编写实战》（覆盖需求分析到用例落地）。  \n• **工具文档**：TestRail官方指南、Pytest官方教程。  \n\n通过以上方法，可系统化提升用例编写效率与质量，降低漏测风险。实际工作中建议结合团队流程（如敏捷迭代）灵活调整策略","tags":["医疗器械","测试","测试用例"],"categories":["interviews"]},{"title":"项目经历总结","url":"/2025/03/14/repos/index/","content":"\n# 项目经历总结\n\n## Film Speak 影音学习应用（2024.11-2025.02）\n**技术栈**：React Native, TypeScript, ffmpeg-kit, Microsoft Speech SDK, Redux, Expo Router\n\n**项目描述**：跨平台视频学习工具，支持视频处理、语音识别与字幕生成功能。\n\n**主要贡献**：\n- 利用ffmpeg-kit在设备本地实现视频转码、剪辑与格式转换，并开发分块处理机制避免内存溢出\n- 集成微软认知服务语音SDK，开发字幕同步算法确保视频与文本精准匹配\n- 使用react-native-mmkv替代AsyncStorage，显著提升存储性能\n- 设计离线工作模式与在线同步机制，确保核心功能在无网络环境下可用\n\n## BEdit 富文本编辑器（2024.09-2024.12）\n**技术栈前端**：Next.js 14, React 18, Material UI, EditableJS, Emotion  \n**技术栈后端**：Flask, erniebot, PaddleOCR, MongoDB\n\n**项目描述**：一款支持AI辅助写作与OCR识别功能的现代富文本编辑器。\n\n**主要贡献**：\n- 前端：基于EditableJS框架设计插件化架构，实现富文本编辑、格式化和协作功能\n- 前端：集成docxyz库实现多种文件格式间的无损转换与导入导出\n- 后端：封装百度文心一言API接口，实现智能对话功能与流式响应输出\n- 后端：集成PaddleOCR实现高效的多语种图文识别转换\n- 配置GitHub Actions工作流，实现前后端代码的自动化部署\n\n## NeteaseCmd 命令行音乐客户端（2024.08-2024.10）\n**技术栈**：Python, MongoDB, RESTful API, Rich, SnowNLP, PyYAML\n\n**项目描述**：功能丰富的网易云音乐命令行客户端，支持音乐搜索下载、歌单管理等功能。\n\n**主要贡献**：\n- 实现WebAPICheck系统监控接口健康状态，自动禁用不可用API\n- 设计基于角色(admin/user/visitor)和分组(basic/music/user/accounting)的权限系统\n- 扩展Python cmd模块，增强命令行功能与自动补全系统\n- 使用MongoDB实现用户数据的跨设备同步与云端自动备份\n- 集成SnowNLP实现音乐评论情感分析功能\n\n## Go语言AI聊天机器人（2024.06-2024.08）\n**技术栈**：Go 1.24, Gin, GORM, MySQL, Azure OpenAI API, Docker\n\n**项目描述**：基于Go语言的高性能AI聊天服务，集成Azure OpenAI大语言模型能力。\n\n**主要贡献**：\n- 采用Server-Sent Events (SSE)技术实现AI回复的实时流式传输\n- 基于UUID设计会话管理系统，实现多轮对话上下文的连贯性维护\n- 构建AIService抽象层封装Azure OpenAI复杂接口，简化业务逻辑集成\n- 设计多阶段构建Dockerfile与Docker Compose配置，优化开发和生产环境一致性\n\n## Joint Player 音乐播放器应用（2024.04-2024.06）\n**技术栈**：React Native, Redux Toolkit, SWR, MMKV, React Navigation, React Native Track Player\n\n**项目描述**：跨平台移动音乐播放器应用，支持多源音乐播放、歌词同步和后台播放功能。\n\n**主要贡献**：\n- 开发基于MMKV的高性能缓存系统，实现LRU缓存淘汰策略和优先级缓存机制\n- 封装TrackPlayer服务，实现音频后台播放、自动队列恢复和歌词同步显示功能\n- 通过useThrottle和useDebounce自定义Hooks优化高频函数调用，提升应用流畅度\n- 实现fetchPlus和retryFetcher工具，集成第三方音乐API并处理网络波动情况\n\n## 君颖投资企业官网（2024.05-2024.07）\n**技术栈**：React 18, React Router 6, SCSS/SASS, GitHub Actions\n\n**项目描述**：响应式企业官网，支持多设备尺寸适配与动态交互效果。\n\n**主要贡献**：\n- 实现自定义`flexible.js`脚本，基于设计稿（1920px）将px统一转换为rem单位\n- 开发滚动视差效果和过渡动画，提升用户视觉体验\n- 使用GitHub Actions工作流实现代码push后自动构建和SFTP部署\n- 优化自定义字体加载策略，提升首屏渲染性能","tags":["技术","项目经历","简历"],"categories":["repos"]},{"title":"基于 Python-Turtle 的创意绘画作品","url":"/2025/03/13/legacy/draw-creative/","content":"\n## 主题阐释\n### 背景\n>随着互联网、大数据、云计算和物联网等技术不断发展，人工智能正引发可产生链式反应的科学突破、催生一批颠覆性技术，加速培育经济发展新动能、塑造新型产业体系，引领新一轮科技革命和产业变革。故创新精神对于身处于智能时代的青少年来说尤为重要。\n\n### 主旨\n看这棵正在成长的大树，它屹立于世界民族之林，扎根于日光之下的东方。它的枝干是如此茂密，枝干之招展是如此广阔，这份浓密，这正是我华夏儿女，炎黄子孙所肩并肩紧挨着凝聚而成，这份广阔，则是中华文化的博大精深，和神州大地的包罗万象。其生长速度之快，也正代表了我们中国发展的腾飞，从绿皮火车到地铁高铁，从车马漫长到全球通信，从机械制图到人工智能，而说到了人工智能，则会想起那个围棋冠军“阿尔法狗”，它的的飞速成长,也正代表了2018年人工智能的进步。在移动互联网、大数据、超级计算和脑科学等新理论新技术的驱动下,问世60余年、遭遇多次质疑的人工智能迎来新一轮发展热潮,真正进入了落地实践阶段，各国新政密集出台、科技巨头纷纷布局、最新进展日新月异……一个“新智能时代”正在到来。在这时代的大背景之下，神州升空，墨子观穹，中国发展不逊于世界任何强国，有如参天大树，以惊人的速度成长起来。而作为新兴“智能时代”下的中国青年，每每看到这天安门，总会想起言语：创新是一个民族的灵魂，是一个国家兴旺发达的不竭动力。新时代的浪涛浩浩汤汤，我们当勇立潮头，在巨浪中把握方向，创新争先，团结奋进，为这枝繁叶茂的中华神树再添上新兴的一笔，为中华民族绽放绚丽多彩的烟花。\n\n## 程序制作过程\n选定作品主题“智能时代 逐梦成长”，确定立意。\n确定作品实现架构。即，使用 Python 编程语言，借助 Turtle 绘图模块绘制创意绘画作品。\n实现程序效果。\n\n### 程序具体流程\n1. 在窗体中央绘制出树干，以树干顶端为中心绘制多层嵌套的五边形，以增添图像美感。\n2. 切换背景后，由左向右绘制树枝，以 Turtle 笔触的 stamp() 当做树叶。\n3. 整棵树绘制完成后，绘画作品的主体绘制完毕。\n4. 在屏幕的随机位置生成 9 个较小的多层嵌套的五边形烟花。\n5. 烟花生成过程中，在生成到第七个烟花时，切换背景图片。\n6. 烟花生成完毕后，以红色宋体 50 号字在窗口右下角处写出字样“创新争先，团结奋进”。\n\n## 编程技巧\n本次项目中，充分运用了函数的递归调用。采用函数式编程，模块化拆分程序功能，使函数调用更灵活，代码更加简洁易懂。\n并采用 try...except 异常处理是程序表现更具人性化。\n\n---\n[基于 Python-Turtle 的创意绘画作品](https://www.kdocs.cn/l/sbF7kf4ShbzN)  \n[青少年创意编程与智能设计大赛](https://www.kdocs.cn/l/sbxs5XKaRjDx)\n","tags":["Python","Turtle"],"categories":["legacy"]},{"title":"Pandoc 简介及使用","url":"/2025/03/13/legacy/pandoc-intro/","content":"\n[Markdown](https://zh.wikipedia.org/zh-cn/Markdown) 是我平时编写各类材料和文章时最喜欢的工具之一，但将其作为文档分发时却略有些不便。毕竟不是所有人都了解 Markdown 的语法，而且它亦不如富文本文档易读。直至我发现了 [Pandoc](http://pandoc.org/)，它可以将文档在 Markdown、LaTeX、reStructuredText、HTML、Word docx 等多种标记格式之间相互转换，并支持输出 PDF、EPUB、HTML 幻灯片等多种格式。\n\n# 程序简介\n\nPandoc 的作者是 [John MacFarlane](http://johnmacfarlane.net/)，他是加州大学伯克利分校的哲学系教授。Pandoc 使用 [Haskell](http://www.haskell.org/)语言编写，被作者用来生成讲义、课件和网站等。该程序开源免费，目前以 GPL 协议托管在 [Github](https://github.com/jgm/pandoc) 上。\n\n# 程序安装\n\nPandoc 的安装有许多方式，但本文只介绍最简单的方法。Pandoc 的作者已经为 Windows、macOS、Linux 等操作系统分别制作了对应的[程序安装包](http://pandoc.org/installing.html)。要使用该程序，只需下载对应的程序安装包进行安装即可。\n\n对于 Ubuntu 等 Linux 发行版，Pandoc 已经被集成到系统的软件源内，因此还可以直接从软件源安装：\n\n```shell\nsudo apt-get install pandoc\n```\n\n或者，如果你已经安装了 Anaconda，那么你可以直接使用 Pandoc 了。该程序已经被集成到 Anaconda 中。\n\n### 参数说明\n\nPandoc 程序的命令使用方式为：\n\n```shell\npandoc \\<files\\> \\<options\\>\n```\n\n其中 \\<files\\> 为输入的内容，其输入即可以来自文件，也可以来自标准输入甚至网页链接。而 \\<options\\> 为参数选项。主要的参数选项有：\n\n```\n-f \\<format\\>、-r \\<format\\>：指定输入文件格式，默认为 Markdown；\n\n-t \\<format\\>、-w \\<format\\>：指定输出文件格式，默认为 HTML；\n\n-o \\<file\\>：指定输出文件，该项缺省时，将输出到标准输出；\n\n\\--highlight-style \\<style\\>：设置代码高亮主题，默认为 pygments；\n\n-s：生成有头尾的独立文件（HTML，LaTeX，TEI 或 RTF）；\n\n-S：聪明模式，根据文件判断其格式；\n\n\\--self-contained：生成自包含的文件，仅在输出 HTML 文档时有效；\n\n\\--verbose：开启 Verbose 模式，用于 Debug；\n\n\\--list-input-formats：列出支持的输入格式；\n\n\\--list-output-formats：列出支持的输出格式；\n\n\\--list-extensions：列出支持的 Markdown 扩展方案；\n\n\\--list-highlight-languages：列出支持代码高亮的编程语言；\n\n\\--list-highlight-styles：列出支持的代码高亮主题；\n\n-v、\\--version：显示程序的版本号；\n\n-h、\\--help：显示程序的帮助信息。\n```\n\n虽然 Pandoc 提供了用于指定输入输出格式的参数，但是很多时候该参数不必使用。Pandoc 已经足够聪明到可以根据文件名判断输入输出格式，所以除非文件名可能造成歧义，否则这两个参数都可以省略。\n\n# 使用示例\n\n## 信息查看\n\n查看程序支持的输入文件格式：\n```shell\n\\$ pandoc \\--list-input-formats\n```\n查看程序支持代码高亮的编程语言：\n```shell\npandoc \\--list-highlight-languages\n```\n查看程序帮助：\n```shell\npandoc \\--help\n```\n生成 HTML 文档\n\n使用 Pandoc 可以很容易地将 Markdown 文档渲染为 HTML 网页：\n```shell\npandoc demo.md -o demo.html\n```\n上面的命令将输出一个 HTML 文档，但该文档不包含任何样式，它的显示效果依赖于你使用的浏览器。我们当然希望可以得到排版更精美的文档，只要在转换时引入自己的层叠样式表 CSS 文件。输入的 CSS 文件可使用 -c 命令来指定：\n```shell\npandoc demo.md -c style.css -o demo.html\n```\n如此输出的 HTML 文档已经包含样式文档了，平时自己查看时，效果很不错。但该方式依然存在部分问题。我们发布或共享文档时，需要传送至少两个文件：1 个 HTML 文件和 1 个 CSS 文件，略有些不便。而如果文档中还包含多个本地图片等文件，共享文档几乎成了不可能的事情。好在 Pandoc 可以将外部文件嵌入到 HTML 文档中，生成一个自包含的独立文件：\n```shell\npandoc demo.md \\--self-contained -c style.css -o demo.html\n```\n在该命令中，\\--self-contained 参数指定：将任何的外部文件嵌入至输出的文件中，形成一个独立的 HTML 文档。这样传送资料时只传送一个文件就可以了，就像分享 PDF 文档一样方便。\n\n## 生成 docx 文档\n\n虽然我很喜欢使用 HTML 作为文档交换格式，但某些情况下你可能还是需要传送 Word docx 文件。这也不是问题，Pandoc 能够将所支持的输入文件一键转换为 Word docx 格式。\n\n下面的命令将一份 Markdown 文件转换为 docx 格式：\n```shell\npandoc demo.md -o demo.docx\n```\n下面的命令将 HTML 网页转换为 docx 格式：\n```shell\n pandoc http://gnss.help/2017/06/12/pandoc-install-usage/ -o this\\_page.docx\n```\n需补充的是：Pandoc 无法为生成的 Word docx 文档指定排版方式。你可能需要二次编辑输出的文件，将标题、正文等调整为满意的样式。\n\n## 生成 PDF 文档\n\n使用 Pandoc 直接生成 PDF 文件时，需要安装 LaTeX。并且，Pandoc 自带的 PDF 引擎不支持中文，必须为中文配置额外的引擎和模板。Pandoc 程序生成 PDF 文件的命令为：\n```shell\npandoc demo.md -o demo.pdf\n```\n我生成 PDF 文档时，未使用以上的方法。而是采用 HTML 文件作为中间文件过渡，使用 Windows 系统的 \"打印到 PDF\" 功能，将 HTML 文档进一步转换为所需的 PDF 文档。\n\n## 生成 Markdown 文档\n\n别忘了 Markdown 也是 Pandoc 支持的输出格式之一，我们可以将任何支持的输入格式转换为 Markdown。这对于我们将之前的文档也切换到 Markdown 格式来说，实在是太方便了。\n\n下面的命令由 Word docx 文档生成 Markdown 文件：\n```shell \n pandoc demo.docx -o demo.md\n```\n下面的命令由 HTML 网页生成 Markdown 文档：\n```shell\n pandoc http://gnss.help/2017/06/12/pand\n```\n\n---\n\n层叠样式表文件决定最终的显示样式，因此有一个漂亮的 CSS 样式表文件非常重要。\n\n在此推荐两个 CSS 文件，首先是由 Alberto Leal 制作的 [Github 风格的样式表文件](https://gist.github.com/Dashed/6714393)，它的显示效果类似于 Github 网站的 README 文档。另一个是我制作的，类似本站曾采用的 [Minos](http://blog.zhangruipeng.me/hexo-theme-minos/) 主题（[Minos-style](https://gist.github.com/purpleskyfall/98ecbccf4f2184aa0f365fbbae36ebdd)）的样式表文件。该文件还未完全稳定，尚需部分完善，不过对付一般的文字排版已经没有问题。\n","tags":["markdown","pandoc"],"categories":["legacy"]},{"title":"Markdown 语法简介","url":"/2025/03/13/legacy/md-intro/","content":"\n# 定义：\n> Markdown 是一种轻量级标记语言，创始人为 John Gruber。它允许人们「使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML）文档」。------维基百科\n\n本文档的目的不在于面面俱到地介绍\nMarkdown，只是作为我对其理解的笔记整理，希望能同时帮助一些对 Markdown\n感兴趣的人快速上手，或是作为一个工具，供对其已经有所了解的人在需要时参考。\n\n接下来请随我一起深入了解这门并不神秘的实用标记语言。\n\n## 背景\n\n### 优点\n\n1.  专注于文字内容；\n\n2.  纯文本，易读易写，可以方便地纳入版本控制；\n\n3.  语法简单，没有什么学习成本，能轻松在码字的同时做出美观大方的排版。\n\n### 使用场景\n\n-   各类代码托管平台\n\n    主流的代码托管平台，如 GitHub、GitLab、BitBucket、Coding、Gitee\n    等等，都支持 Markdown 语法，很多开源项目的\n    README、开发文档、帮助文档、Wiki 等都用 Markdown 写作。\n\n-   技术社区和写作平台\n\n    StackOverflow、CSDN、掘金、简书、GitBook、有道云笔记\n\n-   论坛\n\n    V2EX、光谷社区\n\n个人感觉比较遗憾的一点是各平台可能采用不同语言实现的 Markdown解析引擎，或采用同一解析引擎的不同版本，而且可能有不同程度的定制与扩展，这导致在不同平台上使用Markdown写作时体验并不完全一致。不过幸好对于大家公认的一些标准语法，各家都是支持的。\n\n### 编辑工具\n\n理论上任何一款文本编辑器都能用于编辑 Markdown文档，它们分别提供了不同程度的语法高亮、预览等功能，以下只是列举其中一部分，选择自己称手的即可。\n\n-   现代编辑器\n\n    VSCode / Atom\n\n-   传统编辑器\n\n    Vim / Emacs / Sublime Text / Notepad++\n\n-   IDE 自带编辑器\n\n    IntelliJ IDEA / Android Studio / WebStorm\n\n-   专用编辑器\n\n    Ulysses / Mou / Typora / Markpad\n\n-   在线编辑器\n\n    各种支持 Markdown 的网站都提供了在线编辑器\n\n## 语法\n\n### 标题\n\n**Markdown：**\n``` Markdown\n# atx-style 一级标题\n\n## 二级标题\n\n###### 六级标题\n\n# Setext-style 一级标题\n\n## 二级标题\n```\n**预览效果：**\n\n> atx-style 一级标题\n> ==================\n>\n> 二级标题\n> --------\n>\n> ###### 六级标题\n>\n> Setext-style 一级标题\n> =====================\n>\n> 二级标题\n> --------\n\n**对应 HTML：**\n\n``` html\n<h1>atx-style 一级标题</h1>\n\n<h2>二级标题</h2>\n\n<h6>六级标题</h6>\n\n<h1>Setext-style 一级标题</h1>\n\n<h2>二级标题</h2>\n```\n\n### 段落\n\n中间没有空行的连续不断的几行文字被视为一个段落。\n\n**Markdown：**\n``` markdown\n白日依山尽，\n\n黄河入海流。\n（句号后面没空格）\n\n欲穷千里目，\n\n更上一层楼。  \n（句号后面有俩空格）\n```\n\n**预览效果：**\n\n白日依山尽，\n\n黄河入海流。 （句号后面没空格）\n\n欲穷千里目，\n\n更上一层楼。\\\n（句号后面有俩空格）\n\n**对应 HTML：**\n\n```html\n<p>白日依山尽，</p>\n\n<p>黄河入海流。\n（句号后面没有空格）</p>\n\n<p>欲穷千里目，</p>\n\n<p>\n  更上一层楼。\n  <br>\n  （句号后面有俩空格）\n</p>\n```\n### 行内格式\n\n对段落或者部分文本的强调效果。\n\n**Markdown：**\n``` markdown\n后面俩字**加黑**\n\n后面俩字 *斜体*\n```\n\n**预览效果：**\n\n后面俩字**加黑**\n\n后面俩字*斜体*\n\n**对应 HTML：**\n```html\n<p>\n  后面俩字\n  <strong>加黑</strong>\n</p>\n<p>\n  后面俩字\n  <em>斜体</em>\n</p>\n```\n### 引用块\n\n**Markdown：**\n\n```markdown\n> 引用块段落一。\n>\n> 引用块段落二。\n>> 内嵌引用块段落一。\n>\n> ### 引用块内的标题\n```\n\n**预览效果：**\n\n> 引用块段落一。\n>\n> 引用块段落二。\n>\n> > 内嵌引用块段落一。\n>\n> #### 引用块内的标题\n\n**对应 HTML：**\n``` html\n<blockquote>\n  <p>引用块段落一。</p>\n  <p>引用块段落二。</p>\n  <blockquote>\n    <p>内嵌引用块段落一。</p>\n  </blockquote>\n  <h3 id=\"引用块内的标题\">引用块内的标题</h3>\n</blockquote>\n```\n\n### 超链接\n\nMarkdown 支持行内式链接和引用式链接。\n\n**Markdown：**\n\n``` markdown\n行内式 [博客](https://mazhuang.org \"我的个人博客\") 链接，带 title。\n\n行内式 [GitHub](https://github.com/mzlogin) 链接。\n\n引用式 [博客][1] 链接。\n\n引用式 [GitHub][2] 链接，带 title。\n\n[1]: https://mazhuang.org\n[2]: https://github.com/mzlogin \"我的 GitHub 主页\"\n```\n\n**预览效果：**\n\n行内式 [博客](https://mazhuang.org \"我的个人博客\") 链接，带 title。\n\n行内式 [GitHub](https://github.com/mzlogin) 链接。\n\n引用式 [博客](https://mazhuang.org) 链接。\n\n引用式 [GitHub](https://github.com/mzlogin \"我的 GitHub 主页\") 链接，带\ntitle。\n\n**对应 HTML：**\n\n``` html\n<p>行内式 <a href=\"https://mazhuang.org\" title=\"我的个人博客\">博客</a> 链接，带 title。</p>\n\n<p>行内式 <a href=\"https://github.com/mzlogin\">GitHub</a> 链接。</p>\n\n<p>引用式 <a href=\"https://mazhuang.org\">博客</a> 链接。</p>\n\n<p>引用式 <a href=\"https://github.com/mzlogin\" title=\"我的 GitHub 主页\">GitHub</a> 链接，带 title。</p>\n```\n\n### 图片\n\n在超链接的写法前加一个 **!**，就是引用图片的方法。\n\n**Markdown：**\n\n``` markdown\n![Alt text](https://mazhuang.org/favicon.ico \"favicon\")\n```\n\n**预览效果：**\n\n![Alt text](https://mazhuang.org/favicon.ico \"favicon\")\n\n**对应 HTML：**\n\n``` html\n<img src=\"https://mazhuang.org/favicon.ico\" alt=\"Alt text\" title=\"favicon\">\n```\n\n### 列表\n\n包括有序列表和无序列表。\n\n**Markdown：**\n\n``` markdown\n- 苹果\n- 葡萄\n- 榴莲\n\n1. 苹果\n2. 葡萄\n3. 榴莲\n```\n\n**预览效果：**\n\n-   苹果\n-   葡萄\n-   榴莲\n\n1.  苹果\n2.  葡萄\n3.  榴莲\n\n**对应 HTML：**\n\n``` html\n<ul>\n  <li>苹果</li>\n  <li>葡萄</li>\n  <li>榴莲</li>\n</ul>\n<ol>\n  <li>苹果</li>\n  <li>葡萄</li>\n  <li>榴莲</li>\n</ol>\n```\n\n其中无序列表的标记可以使用`+`、`-`或`*`，有序列表前的数字可以是乱序的。\n\n### 代码块\n\n支持行内代码和代码块。\n\n**Markdown：**\n\n```` markdown\nAndroid 里使用 `TextUtils` 类的 `isEmpty` 方法来判断字符串是否为空。\n\n``` java\nif (TextUtils.isEmpty(text)) {\n    return null;\n}\n```\n````\n\n**预览效果：**\n\nAndroid 里使用 `TextUtils`类的`isEmpty`方法来判断字符串是否为空。\n\n``` java\nif (TextUtils.isEmpty(text)) {\n    return null;\n}\n```\n\n**对应 HTML：**\n\n``` html\n<p>Android 里使用 <code>TextUtils</code> 类的 <code>isEmpty</code> 方法来判断字符串是否为空。</p>\n\n<div class=\"highlight highlight-source-java\"><pre><span class=\"pl-k\">if</span> (<span class=\"pl-smi\">TextUtils</span><span class=\"pl-k\">.</span>isEmpty(text)) {\n    <span class=\"pl-k\">return</span> <span class=\"pl-c1\">null</span>;\n}</pre></div>\n```\n\n上例中的语言标记 `java`\n可选填，可用于在编辑器和渲染后的效果里添加语法高亮。\n\n块式代码也可以对整个代码段缩进四个空格，或一个 Tab 来实现。\n\n### 水平分割线\n\n使用一个单独行里的三个或以上\n`*`、`-`来生产一条水平分割线，它们之间可以有空格。\n\n**Markdown：**\n\n``` markdown\n***\n\n-----\n\n- - -\n```\n\n**预览效果：**\n\n---\n\n---\n\n---\n\n**对应 HTML：**\n\n``` html\n<hr />\n\n<hr />\n\n<hr />\n```\n\n### 嵌入 HTML\n\nMarkdown 标记语言的目的不是替代 HTML，也不是发明一种更便捷的插入 HTML标签的方式。它对应的只是 HTML 标签的一个很小的子集。\n\n对于那些没有办法用 Markdown 语法来对应的 HTML 标签，直接使用 HTML\n来写就好了。\n\n## 扩展语法\n\n本节的内容是介绍一些受到广泛支持的 Markdown 扩展语法。\n\n### 表格\n\n**Markdown：**\n\n``` markdown\n| 编号  | 姓名（左） | 年龄（右） | 性别（中） |\n| ----- | :-------- | ---------: | :------: |\n| 0     | 张三       | 28         | 男       |\n| 1     | 李四       | 29         | 男       |\n```\n**预览效果：**\n\n  | 编号 |   姓名（左）    | 年龄（右） | 性别（中）|\n  | ------ | :------------ | ------------: | :------------: |\n  |0     | 张三         |          28  |    男   |\n | 1    |   李四           |   29   |   男 |\n\n**对应 HTML：**\n\n``` html\n<table>\n  <thead>\n    <tr>\n      <th>编号</th>\n      <th align=\"left\">姓名（左）</th>\n      <th align=\"right\">年龄（右）</th>\n      <th align=\"center\">性别（中）</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td align=\"left\">张三</td>\n      <td align=\"right\">28</td>\n      <td align=\"center\">男</td>\n    </tr>\n    <tr>\n      <td>1</td>\n      <td align=\"left\">李四</td>\n      <td align=\"right\">29</td>\n      <td align=\"center\">男</td>\n    </tr>\n  </tbody>\n</table>\n```\n\n### 任务列表\n\n在 GitHub / GitLab 里有较好的支持。\n\n**Markdown：**\n\n``` markdown\n- [x] 洗碗\n- [ ] 清洗油烟机\n- [ ] 拖地\n```\n\n**预览效果：**\n\n- [x]  洗碗\n- [ ]  清洗油烟机\n- [ ]  拖地\n\n**对应 HTML：**\n\n``` html\n<ul class=\"contains-task-list\">\n  <li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\" checked=\"\"> 洗碗</li>\n  <li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\"> 清洗油烟机</li>\n  <li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\"> 拖地</li>\n</ul>\n```\n\n如果是在 GitHub / GitLab 的 Issue 里，会附赠任务完成比例提示效果：\n\n![task list1](https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/task-list-1.png)\n\n还可以直接在网页上拖动调整顺序，勾选和取消勾选。\n\n![task list2](https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/task-list-2.png)\n\n### 删除线\n\n**Markdown：**\n\n``` marjdown\n后面三个字打上~~删除线~~。\n```\n\n**预览效果：**\n\n后面三个字打上~~删除线~~。\n\n**对应 HTML：**\n\n``` html\n<p>后面三个字打上<del>删除线</del>。</p>\n```\n\n### 自动链接\n\n自动链接扩展，即：当识别到 URL，或用\n`<`、`>` 包括的 URL\n时，会自动为其生成 `a` 标签。\n\n**Markdown：**\n\n``` markdown\nhttps://github.com\n\n<example@gmail.com>\n```\n\n**预览效果：**\n\nhttps://github.com\n\n<example@gmail.com>\n\n**对应 HTML：**\n\n``` html\n<p><a href=\"https://github.com\">https://github.com</a></p>\n\n<p><a href=\"mailto:example@gmail.com\">example@gmail.com</a></p>\n```\n\n### emoji\n\n以 GitHub Pages 为例。\n\n**Markdown：**\n\n``` markdown\n:camel: :blush: :smile:\n```\n\n**预览效果：**\n\n![:camel:](https://github.githubassets.com/images/icons/emoji/unicode/1f42b.png \":camel:\")\n![:blush:](https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png \":blush:\")\n![:smile:](https://github.githubassets.com/images/icons/emoji/unicode/1f604.png \":smile:\")\n\n**对应 HTML：**\n\n``` html\n<p>\n  <img class=\"emoji\" title=\":camel:\" alt=\":camel:\" src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f42b.png\" height=\"20\" width=\"20\">\n  <img class=\"emoji\" title=\":blush:\" alt=\":blush:\" src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f60a.png\" height=\"20\" width=\"20\">\n  <img class=\"emoji\" title=\":smile:\" alt=\":smile:\" src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png\" height=\"20\" width=\"20\">\n</p>\n```\n\n### 奇技淫巧\n\n脑洞清奇的工程师们还发掘了很多使用 Markdown 的方法，大部分都是引入第三方\nJavaScript\n插件来实现。对这部分我只做简述，对其中的部分功能比如作图等，还是推荐用专门的可视化工具去做。\n\n### 画流程图和时序图\n\n有部分网站和编辑器实现了对 Markdown\n里流程图和时序图的支持，比如我们使用的项目管理工具 TAPD\n的在线编辑器，还有 VSCode + 插件 Markdown Preview Enhanced 等。\n\n以我们使用的项目管理工具 TAPD 的在线编辑器为例：\n\n![流程图](https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/tapd-markdown-flowchart.png)\n\n![时序图](https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/tapd-markdown-seq.png)\n\n### 插入数学公式\n\n仍然以 TAPD 为例：\n\n![数学公式](https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/tapd-markdown-math.png)\n\n应该是利用 JavaScript 支持了 LaTeX 公式语法。\n\n### 用 Markdown 做 PPT\n\n有专门的工具 [Marp](https://github.com/yhatt/marp)，另外使用 VSCode + 插件 Markdown Preview Enhanced 也可以实现。\n\n### 用 Markdown 写微信公众号\n\n可以将公众号素材用 Markdown\n编辑好后，贴到在线排版工具以后，复制到公众号编辑器里即可。有多种页面主题和代码主题可选择。\n\n我维护的工具地址：<https://md.mazhuang.org>\n\n![微信公众号](https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/wechat-markdown.png)\n\n### 更多\n\n想象力丰富的工程师们还扩展了很多基于 Markdown 的玩法，包括但不限于：\n\n-   自动生成 / 更新 Table of Contents\n-   流程图 / 时序图\n-   制作幻灯片\n-   集成 PlantUML / GraphViz 的能力\n-   导出 HTML / PDF / 电子书\n-   ...\n\n以上功能基本都可以用 VSCode + 插件 Markdown Preview Enhanced 实现。\n\n另外可以参考我以前的一篇博客 [关于 Markdown\n的一些奇技淫巧](https://mazhuang.org/2017/09/01/markdown-odd-skills/)。\n\n## 参考\n\n-   [Markdown: Syntax - DARING\n    FIREBALL](https://daringfireball.net/projects/markdown/syntax)\n-   [Markdown - 维基百科](https://zh.wikipedia.org/wiki/Markdown)\n-   [GitHub Flavored Markdown Spec](https://github.github.com/gfm/)\n-   [关于 Markdown的一些奇技淫巧](https://mazhuang.org/2017/09/01/markdown-odd-skills/)\n","tags":["markdown","syntax"],"categories":["legacy"]},{"title":"NeteaseCmd 项目经历总结","url":"/2025/03/13/repos/netease-cmd/","content":"\n# 网易云音乐命令行客户端项目经历总结\n\n## 项目概述\nNeteaseCmd 是一个功能丰富的网易云音乐命令行客户端，支持音乐搜索下载、歌单管理、MV下载、评论查看等功能，同时实现了完整的用户权限管理系统。\n\n## 技术栈\n\n### 后端与核心技术\n- **Python** 作为主要开发语言\n- **CMD模块扩展** 实现交互式命令行界面\n- **MongoDB** 用于数据持久化存储（用户账户、日志、搜索历史等）\n- **RESTful API** 对接网易云音乐非官方API\n- **PDM** 用于依赖管理\n\n### 工具库\n- **requests** 处理HTTP请求\n- **rich** 实现丰富的命令行UI（表格、进度条等）\n- **colorama** 提供彩色终端输出\n- **loguru** 实现结构化日志\n- **SnowNLP** 进行自然语言处理和情感分析\n- **PyYAML** 处理配置文件\n\n## 技术难点与解决方案\n\n### 1. 网易云音乐API调用与稳定性\n- **难点**：网易云API缺乏官方文档，接口可能不稳定\n- **解决方案**：\n  - 实现WebAPICheck系统进行接口健康检查\n  - 设计自动禁用不可用API机制\n  - 自定义异常处理机制捕获API错误\n\n### 2. 权限与安全系统设计\n- **难点**：需要细粒度的用户权限控制，保护敏感操作\n- **解决方案**：\n  - 设计基于角色(admin/user/visitor)的权限系统\n  - 实现权限分组(basic/music/user/accounting)\n  - 使用SHA-256哈希算法存储密码\n  - 命令执行前的权限预检查机制\n\n### 3. 命令行交互优化\n- **难点**：命令行界面交互体验通常较差\n- **解决方案**：\n  - 扩展Python cmd模块，增强命令行功能\n  - 实现命令自动补全系统\n  - 使用rich库展示结构化表格数据\n  - 设计多层命令模式(管理员模式、用户模式)\n\n### 4. 数据持久化与备份\n- **难点**：本地数据易丢失，需要可靠备份\n- **解决方案**：\n  - 设计云端自动备份系统\n  - 实现增量数据上传\n  - 使用MongoDB实现数据跨设备同步\n\n### 5. 用户体验增强功能\n- **难点**：提高命令行应用的用户友好度\n- **解决方案**：\n  - 实现下载进度可视化\n  - 使用NLP技术分析音乐评论情感\n  - 设计记忆化搜索历史功能\n  - 日志系统集成Slack通知\n\n## 项目收获\n通过此项目，深入掌握了Python高级特性、命令行应用设计模式、MongoDB数据存储技术，以及RESTful API对接技巧。特别是在权限管理、用户认证和命令行交互体验优化方面积累了丰富经验。","tags":["Python","MongoDB","RESTful API","CLI","User Management"],"categories":["repos"]},{"title":"君颖投资项目经历简介","url":"/2025/03/13/repos/jy-web/","content":"\n# 君颖投资项目经历简介\n\n## 技术栈\n\n### 前端框架与库\n- **React 18** 构建用户界面\n- **React Router DOM 6** 实现客户端路由\n- **SCSS/SASS** 编写模块化、可维护的样式\n- **normalize.css** 确保跨浏览器样式一致性\n- **classnames** 实现条件类名管理\n- **react-transition-group** 处理组件过渡动画\n\n### 构建与部署\n- **Create React App** 脚手架工具\n- **GitHub Actions** 实现CI/CD自动化部署\n- **SFTP-Deploy-Action** 自动部署到服务器\n\n## 技术难点与解决方案\n\n### 1. 响应式布局适配\n- **难点**：需要在不同设备上保持一致的用户体验\n- **解决方案**：\n  - 实现自定义的`flexible.js`脚本动态设置根字体大小\n  - 基于设计稿（1920px）将px统一转换为rem单位\n  - 通过媒体查询适配不同设备尺寸\n\n### 2. 滚动交互与视差效果\n- **难点**：实现平滑的滚动视差效果和过渡动画\n- **解决方案**：\n  - 监听页面滚动事件，动态调整背景位置：`parallax.style.backgroundPositionY = scrollPosition * 0.7 + \"px\"`\n  - 结合CSS过渡和JavaScript控制，实现导航栏滚动样式变化\n  - 基于元素可见性触发动画（如联系页表单出现动画）\n\n### 3. 跨组件状态管理\n- **难点**：管理复杂的UI状态（如手风琴组件）\n- **解决方案**：\n  - 使用React状态钩子精确控制UI交互状态\n  - 实现状态提升以管理兄弟组件间的状态\n  - 通过React.memo优化组件渲染性能\n\n### 4. 字体与资源加载优化\n- **难点**：自定义字体可能影响加载性能\n- **解决方案**：\n  - 使用@font-face实现中文自定义字体加载\n  - 通过合适的字体格式和加载策略提升用户体验\n  - 图片资源按需加载，避免初始加载过大\n\n### 5. 自动化部署流程\n- **难点**：保证部署流程的稳定性和效率\n- **解决方案**：\n  - 配置GitHub Actions工作流，实现push代码后自动构建和部署\n  - 实现了SSH身份验证自动化，确保安全部署\n  - 优化构建过程，减小生产包体积\n\n通过这个项目，不仅提升了React组件设计和前端工程化能力，也积累了响应式开发和自动化部署的实战经验。","tags":["React","Web","SCSS","GitHub Actions","SFTP"],"categories":["repos"]},{"title":"Imgv-Webapp项目经历总结","url":"/2025/03/13/repos/imgv-web/","content":"\n# imgv-webapp项目经历总结\n\n## 技术栈\n\n### 后端技术\n- **Flask**: 主要Web框架，支持异步处理\n- **uWSGI**: 生产环境部署服务器\n- **Python异步**: 使用asyncio和异步Flask处理并发请求\n- **第三方API集成**: 与lolicon.app图片API对接\n\n### 前端技术\n- **Jinja2模板引擎**: 用于服务端渲染HTML\n- **响应式设计**: 针对PC、平板和手机的自适应界面\n\n### 工具链\n- **PDM**: Python依赖管理工具\n- **loguru**: 高级日志记录框架\n- **requests/httpx**: HTTP请求库(同步/异步)\n- **user-agents**: 用户设备识别库\n\n## 技术难点与解决方案\n\n### 1. 异步并发图片下载\n**难点**: 需处理多个图片的并发下载请求，避免线程阻塞\n**解决方案**: \n- 实现`_downloads`异步方法处理批量图片下载\n- 使用`asyncio.gather`收集和处理多个异步任务\n- 通过httpx库实现异步HTTP请求\n\n### 2. 多设备自适应界面\n**难点**: 需要在不同设备上提供最佳用户体验\n**解决方案**:\n- 使用user-agents库检测访问设备类型\n- 根据设备类型(PC/平板/手机)动态调整图片大小和布局\n- 实现针对移动设备的特殊交互功能(如返回顶部按钮)\n\n### 3. 日志系统设计\n**难点**: 需要统一管理不同来源的日志记录\n**解决方案**:\n- 自定义`InterceptHandler`类集成标准logging和loguru\n- 实现日志轮转、压缩和自动清理策略\n- 优化日志格式便于问题排查\n\n### 4. API请求安全与稳定性\n**难点**: 外部API请求可能被识别为爬虫而被拒绝\n**解决方案**:\n- 实现随机User-Agent轮换和HTTP头部模拟\n- 加入文件名安全处理机制，避免非法字符\n- 完善的异常处理和用户友好的错误页面\n\n这个项目展示了我在全栈Web开发、异步编程和API集成方面的综合能力，尤其是在处理高并发请求和提供跨设备用户体验方面的专业技能。","tags":["Python","Flask","Web","Async","Jinja2","User-Agent"],"categories":["repos"]},{"title":"Image Viewer (Imgv-Cmd) 项目经历总结","url":"/2025/03/13/repos/imgv-cmd/","content":"\n# ImageViewer 项目经历总结\n\n## 项目概述\nImageViewer 是一个命令行图片浏览工具，能够从在线API获取图片，本地显示、管理和存储图片信息。该工具支持关键词搜索、图片预览、二维码生成和数据持久化等功能。\n\n## 技术栈\n\n### 编程语言与环境\n- Python 3.8\n- 命令行应用程序\n\n### 数据存储\n- SQLite 数据库 (存储图片元数据)\n\n### 核心库与框架\n- requests: HTTP请求处理\n- matplotlib: 图片显示和处理\n- loguru: 结构化日志记录\n- rich: 终端美化输出\n- notifiers: Slack通知集成\n- PyQRCode: 生成图片URL的二维码\n- multiprocessing: 并行任务处理\n- argparse: 命令行参数解析\n\n### 开发工具\n- PyCharm/VSCode: 开发环境\n- Git: 版本控制\n\n## 技术难点与解决方案\n\n### 1. 并行下载优化\n**难点**：需要高效下载多张图片，避免串行下载带来的性能瓶颈\n**解决方案**：\n- 利用Python multiprocessing模块的进程池(Pool)实现并行下载\n- 为每个图片分配独立进程，显著提升下载速度\n\n```python\ndef download_all(self, temp=True):\n    pool = Pool(self.count)\n    for pic in self.pic_objs:\n        pool.apply_async(pic.download, args=(None, temp))\n    pool.close()\n    pool.join()\n```\n\n### 2. 数据持久化与管理\n**难点**：需要安全有效地存储和管理图片元数据\n**解决方案**：\n- 设计SQLite数据库结构存储图片信息\n- 实现自动创建数据库表结构的功能\n- 开发数据上传与查询接口\n\n### 3. 用户体验优化\n**难点**：命令行工具易用性与功能丰富性的平衡\n**解决方案**：\n- 设计直观的命令行参数系统，支持多种查询和显示选项\n- 利用rich库美化终端输出，提升信息可读性\n- 集成二维码生成功能，便于在移动设备上访问图片URL\n\n### 4. 日志与通知系统\n**难点**：需要实时跟踪程序运行状态并通知团队\n**解决方案**：\n- 利用loguru实现多级别日志记录\n- 集成Slack API，实现关键事件的即时通知\n- 支持本地日志与远程通知的灵活切换\n\n### 5. 错误处理与异常管理\n**难点**：确保程序在各种异常情况下仍能稳定运行\n**解决方案**：\n- 实现全面的异常捕获和处理机制\n- 使用装饰器(@logger.catch())自动记录异常信息\n- 为用户提供友好的错误提示\n\n## 项目成果\n- 开发了一个功能完整、易于使用的命令行图片浏览工具\n- 实现了高效的并行下载、本地预览和数据管理功能\n- 构建了可扩展的架构，便于未来功能扩展\n\n这个项目展示了我在Python应用开发、API集成、数据管理和用户体验设计方面的综合能力。","tags":["Python","Command Line","SQLite","Requests","Matplotlib","Loguru","Rich","Notifiers","PyQRCode","Multiprocessing","argparse"],"categories":["repos"]},{"title":"Image Viewer (Imgv) 项目经历总结","url":"/2025/03/13/repos/imgv-app/","content":"\n# Image Viewer (imgv) 项目经历总结\n\n## 技术栈\n\n### 前端框架\n- **React Native** - 跨平台移动应用开发框架\n- **TypeScript** - 强类型代码支持\n- **Expo** - React Native开发工具集\n\n### UI组件与交互\n- **React Native Paper** - Material Design组件库\n- **React Navigation** - 屏幕导航管理\n- **Lottie** - 精美动画效果\n- **Reanimated** - 流畅的动画交互\n- **React Native Vector Icons** - 图标支持\n\n### 状态管理\n- **Redux Toolkit** - 应用状态管理\n- **AsyncStorage** - 本地数据持久化\n\n### 多语言支持\n- **i18next** + **react-i18next** - 国际化框架\n- **react-native-localize** - 系统语言检测\n\n### 功能增强\n- **react-native-fast-image** - 高性能图片加载\n- **react-native-fs** - 文件系统操作\n- **react-native-webview** - 内置浏览器支持\n- **react-native-haptic-feedback** - 触觉反馈增强体验\n- **Sentry** - 错误监控和崩溃报告\n\n## 技术难点及解决方案\n\n### 1. 图片资源高效管理\n**难点**：大量高清图片加载导致内存占用高、页面卡顿\n**解决方案**：\n- 实现自动清理图片缓存机制(`clearImageCache`)\n- 使用`react-native-fast-image`优化图片加载\n- 采用滚动加载时动态移除不可见图片的策略\n- 实现图片质量选择功能，根据网络条件优化加载\n\n### 2. 复杂状态管理\n**难点**：多组件间状态共享、持久化存储与恢复\n**解决方案**：\n- 使用Redux Toolkit集中管理应用状态\n- 封装Storage类简化AsyncStorage操作\n- 实现数据导入导出功能，支持用户数据备份与迁移\n- 使用React hooks优化组件状态管理\n\n### 3. 流畅的用户体验\n**难点**：确保应用响应迅速、动画流畅、交互自然\n**解决方案**：\n- 使用Reanimated实现高性能动画\n- 添加触觉反馈增强交互感知\n- 实现下拉刷新和无限滚动加载\n- 使用`useCallback`和`useMemo`优化渲染性能\n- 自定义动画加载屏幕提升启动体验\n\n### 4. API数据处理与展示\n**难点**：处理外部API数据结构转换、错误处理和状态同步\n**解决方案**：\n- 封装API请求函数，统一错误处理\n- 实现`machineData`函数处理API返回数据格式\n- 使用UUID确保数据项唯一识别\n- 添加错误重试机制和友好的用户提示\n\n### 5. 多语言和主题支持\n**难点**：提供无缝的多语言切换和主题适配\n**解决方案**：\n- 使用i18next实现完整的多语言支持框架\n- 支持手动设置语言或跟随系统设置\n- 实现Material 3动态主题系统\n- 支持明暗两套主题，适配系统主题变化\n\n### 6. 应用版本与更新管理\n**难点**：维护一致的版本号系统，支持应用内更新\n**解决方案**：\n- 自定义versioning脚本管理应用版本\n- 实现应用内检查更新功能\n- 支持构建号自动递增\n- 优化应用升级流程，提供平滑升级体验\n\n此项目锻炼了我在React Native跨平台开发方面的综合能力，包括UI/UX设计、性能优化、状态管理和API集成等多个方面，使我能够从容应对各种移动应用开发挑战。","tags":["React Native","TypeScript","Redux","Expo","Material Design","i18next","AsyncStorage","Reanimated","React Navigation","Lottie","Sentry"],"categories":["repos"]},{"title":"Bettar 项目经历简介","url":"/2025/03/13/repos/bettar-web/","content":"\n# Bettar 项目经历简介\n\n## 技术栈\n\n### 前端框架\n- **Next.js 14.0.3** - 用于服务端渲染和静态网站生成的React框架\n- **React 18.2.0** - 用于构建用户界面的JavaScript库\n\n### UI/组件库\n- **Bootstrap 5.3.2** - 响应式CSS框架\n- **React Bootstrap 2.9.1** - Bootstrap的React实现\n\n### 动画与交互\n- **Framer Motion 10.16.5** - React动画库，用于创建平滑过渡和复杂动画\n- **React Just Parallax 3.1.16** - 实现视差滚动效果\n- **Swiper 11.0.5** - 触摸滑动轮播库\n\n### 开发工具\n- **TypeScript** - 静态类型检查\n- **ESLint** - 代码质量控制\n\n## 技术难点与解决方案\n\n### 难点1：服务端渲染与客户端水合不匹配问题\n- **问题描述**：在Next.js中，服务端渲染的HTML与客户端JavaScript尝试\"水合\"(hydration)时出现不匹配错误\n- **解决方法**：\n  - 实现了自定义错误监控系统，利用Next.js的错误追踪机制\n  - 通过分析和分组错误堆栈帧来快速定位水合不匹配的源头\n  - 采用条件渲染策略，确保服务端与客户端渲染结果一致\n\n### 难点2：复杂动画性能优化\n- **问题描述**：实现视差效果和复杂动画时遇到性能瓶颈，特别是在移动设备上\n- **解决方法**：\n  - 利用Framer Motion的懒加载和减少重渲染的特性\n  - 实现基于可视区域的动画触发，避免不必要的计算\n  - 通过React.memo和useCallback优化组件重渲染\n\n### 难点3：多框架集成与类型安全\n- **问题描述**：整合多个第三方库时的类型定义冲突和版本兼容问题\n- **解决方法**：\n  - 使用TypeScript严格模式确保类型安全\n  - 创建自定义类型定义文件解决第三方库类型缺失问题\n  - 实现模块化架构，降低各组件间的耦合度\n\n这个项目展示了我在现代前端开发中处理复杂渲染问题、性能优化以及多框架集成的能力，特别是在Next.js和React生态系统中的深入应用。","tags":["Next.js","React","Repos"],"categories":["repos"]},{"title":"Joint Player 项目经验总结","url":"/2025/03/13/repos/joint-player/","content":"\n# Joint Player 项目经验总结\n\n## 技术栈\n\n### 前端框架与核心技术\n- **React Native 0.75.4**: 跨平台移动应用开发\n- **Redux/RTK**: 使用@reduxjs/toolkit和redux-persist进行状态管理和持久化\n- **React Navigation**: 实现应用路由与导航功能\n- **SWR**: 用于数据获取、缓存和状态同步\n\n### UI与交互\n- **React Native Paper**: Material Design风格的UI组件库\n- **React Native Reanimated**: 高性能动画系统\n- **React Native Gesture Handler**: 手势控制系统\n\n### 多媒体处理\n- **React Native Track Player**: 音频播放控制，支持后台播放\n- **React Native Video**: 视频播放功能\n\n### 存储与性能\n- **MMKV**: 高性能键值存储\n- **Expo**: 部分模块使用Expo库简化开发\n\n### 其他技术\n- **i18next**: 国际化多语言支持\n- **Sentry**: 错误监控与追踪\n- **Jest**: 单元测试\n\n## 技术难点及解决方案\n\n### 1. 高性能缓存系统实现\n- **难点**: 移动应用需要高效管理大量音乐数据和API响应的缓存\n- **解决方案**: \n  - 开发了基于MMKV的自定义缓存系统，实现`MMKVStorageProvider`类\n  - 采用LRU(最近最少使用)缓存淘汰策略\n  - 针对不同类型数据实现了优先级缓存机制\n  - 通过缓存事件系统支持数据自动重载\n\n### 2. 音频播放与控制优化\n- **难点**: 需要实现高质量的音频播放体验，包括后台播放与系统集成\n- **解决方案**:\n  - 封装`TrackPlayer`服务，实现自动队列恢复\n  - 自定义`useSetupPlayer`Hook处理播放器初始化和状态恢复\n  - 实现了歌词同步显示和滚动功能\n\n### 3. 性能优化与用户体验\n- **难点**: 移动应用需要在性能有限的设备上保持流畅体验\n- **解决方案**:\n  - 实现`useThrottle`和`useDebounce`自定义Hooks控制高频函数调用\n  - 通过`initFocus`机制处理应用状态转换和数据同步\n  - 使用批处理策略优化渲染和状态更新\n\n### 4. API集成与网络优化\n- **难点**: 需要稳定集成第三方音乐API并处理网络波动\n- **解决方案**:\n  - 开发了`fetchPlus`和`retryFetcher`工具，实现自动重试和错误恢复\n  - 通过SWR实现数据缓存和快速响应\n\n### 5. 版本管理自动化\n- **难点**: 需要高效管理应用版本号和构建流程\n- **解决方案**:\n  - 实现了版本号自动递增系统\n  - 开发了针对Android和iOS平台的构建脚本\n\n## 项目成果\n- 成功开发了一个支持多平台的音乐播放器应用\n- 实现了稳定的音乐播放、歌词同步和多语言支持功能\n- 通过性能优化和缓存策略，提供了流畅的用户体验","tags":["React Native","MMKV","TypeScript","Redux","Redux-Persist"],"categories":["repos"]},{"title":"BEdit前端项目技术栈分析","url":"/2025/03/13/repos/bedit-frontend/","content":"\n# bedit 项目技术栈分析\n\n## 技术栈\n\n### 前端框架\n- **Next.js 14.2.4**: 服务端渲染React框架，优化SEO和首屏加载性能\n- **React 18**: 核心UI构建库，支持并发渲染和Suspense等新特性\n\n### 编辑器功能\n- **EditableJS系列**: 基于现代Web技术的富文本编辑器框架\n  - 插件化架构: history、title、toolbar等插件支持\n- **docxyz**: 文档格式转换库，支持多种文档格式间的互转\n\n### UI组件库与样式方案\n- **Material UI 5.15.x**: 完整的React组件库，实现了Material Design设计规范\n- **Emotion**: 高性能的CSS-in-JS解决方案\n  - 支持样式隔离、动态主题和服务端渲染\n\n### 工具库\n- **file-saver**: 客户端文件保存功能\n- **lru-cache**: 最近最少使用缓存算法实现\n- **sharp**: 高性能图像处理\n- **uuid**: 唯一标识符生成\n\n## 可能的技术难点与解决方案\n\n### 富文本编辑器实现\n- **难点**: 实现复杂的文本编辑、格式化和协作功能\n- **解决方案**: 采用EditableJS框架的插件化架构，模块化开发各种编辑功能\n\n### 文档导入导出\n- **难点**: 支持多种文件格式的无损转换\n- **解决方案**: 整合docxyz库处理文档转换，file-saver实现客户端文件保存\n\n### 性能优化\n- **难点**: 大型文档的编辑性能和响应速度\n- **解决方案**: 使用lru-cache实现数据缓存，Next.js提供的代码分割和预加载功能\n\n### UI/UX设计\n- **难点**: 创建直观且响应式的编辑器界面\n- **解决方案**: 利用Material UI组件库构建一致的用户界面，Emotion提供灵活的样式管理\n\n### 跨平台兼容性\n- **难点**: 确保在不同设备和浏览器上的一致体验\n- **解决方案**: Next.js的现代化构建流程，确保代码兼容性和优化\n\n这个项目展示了构建现代化Web编辑器应用的完整技术栈实现，结合了高性能前端框架与专业编辑器库。","tags":["Next.js","React","Material UI","Emotion"],"categories":["repos"]},{"title":"Voice Scroll 提词器应用项目总结","url":"/2025/03/13/repos/voice-scroll/","content":"\n# Voice Scroll 提词器应用项目总结\n\n## 技术栈\n\n### 前端框架与语言\n- **React Native + Expo**：搭建跨平台(iOS/Android)移动应用\n- **TypeScript**：提供类型安全和代码可维护性\n- **Redux Toolkit**：状态管理\n- **Redux Persist**：数据持久化存储\n\n### UI与交互\n- **React Native Paper**：实现Material Design风格组件\n- **React Navigation**：应用路由管理\n- **Expo Router**：页面导航系统\n- **Reanimated**：流畅动画效果\n\n### 核心功能组件\n- **Expo Speech Recognition**：语音识别功能\n- **Expo Screen Orientation**：横竖屏切换\n- **Expo File System & Document Picker**：文件操作\n- **Expo Haptics**：触觉反馈\n\n## 技术难点及解决方案\n\n### 1. 语音识别与文本匹配算法\n- **难点**：实现准确的语音识别和文本位置匹配，特别是在不完整识别情况下\n- **解决方案**：\n  - 实现了基于搜索范围的文本匹配算法(`findBestMatch`)\n  - 采用短语权重和位置权重相结合的评分机制\n  - 使用多段落上下文比对提高匹配准确率\n\n### 2. 平滑滚动控制系统\n- **难点**：实现精确且流畅的文本滚动体验\n- **解决方案**：\n  - 自定义`ScrollController`类，基于`requestAnimationFrame`实现高性能动画\n  - 实现变速滚动控制，支持用户自定义滚动速度\n  - 优化渲染性能，减少不必要的重绘\n\n### 3. 高效状态管理与数据持久化\n- **难点**：处理复杂应用状态和用户数据\n- **解决方案**：\n  - 使用Redux分片架构，将状态按功能模块拆分\n  - 结合Redux Persist实现脚本、设置的持久化存储\n  - 使用AsyncThunk处理异步操作，提高代码可维护性\n\n### 4. 跨平台自适应布局\n- **难点**：适配不同设备尺寸和方向的显示效果\n- **解决方案**：\n  - 实现响应式设计，根据屏幕尺寸动态调整布局\n  - 针对平板和手机设计不同交互模式\n  - 横屏/竖屏模式无缝切换，优化全屏体验\n\n### 5. 文本处理与格式化\n- **难点**：高效处理大型文本脚本和多种格式\n- **解决方案**：\n  - 实现文本分段解析与渲染\n  - 使用FlatList的虚拟列表优化长文本性能\n  - 使用节流技术(debounce)优化自动保存功能\n\n## 项目成果\n- 完成了支持语音识别的跨平台提词器应用\n- 实现了多项专业功能：镜像显示、自动滚动、脚本库管理\n- 优化了移动端交互体验，包括手势操作和触觉反馈\n- 设计了直观的用户界面，支持深色/浅色主题切换\n\n这个项目展示了全栈移动应用开发能力，特别是在复杂功能实现、用户体验优化和跨平台适配方面的技术实力。","tags":["React Native","Speech Recognition","Expo","Redux-Persist","Scroll Control"],"categories":["repos"]},{"title":"BEdit后端项目经历总结","url":"/2025/03/13/repos/bedit-backend/","content":"\n# BEdit后端项目经历总结\n\n## 技术栈\n\n1. **核心框架与库**\n   - Flask - 构建Web API服务\n   - erniebot - 集成百度文心一言AI模型\n   - PaddleOCR - 实现图像文字识别功能\n   - MongoDB - 数据存储\n\n2. **部署与运维**\n   - PDM - Python项目依赖管理\n   - Waitress - 生产环境WSGI服务器\n   - GitHub Actions - CI/CD自动化部署\n\n3. **工具库**\n   - Loguru - 日志管理系统\n   - Flask-CORS - 处理跨域资源共享\n   - pytoml - 项目配置管理\n\n## 技术难点\n\n1. **AI大模型集成**\n   - 难点：接入百度文心一言API，实现智能对话功能\n   - 解决方法：采用erniebot库封装API调用，实现流式和非流式响应处理，并使用初始化消息列表确保模型身份一致性\n\n2. **OCR图像识别**\n   - 难点：需从图片中提取文字内容，支持多语种识别\n   - 解决方法：集成PaddleOCR库，封装识别流程，实现高效的图文转换API\n\n3. **异步流式响应**\n   - 难点：实现AI模型的实时流式输出，提升用户交互体验\n   - 解决方法：使用Flask的stream_with_context和生成器函数，结合erniebot的流式接口实现数据流输出\n\n4. **数据持久化**\n   - 难点：聊天历史记录需要高效存储与检索\n   - 解决方法：设计封装MongoDB操作的DBHandler类，实现通用数据增删改查功能\n\n5. **日志系统集成**\n   - 难点：统一多个库的日志记录行为，便于问题排查\n   - 解决方法：使用Loguru配置统一日志格式，通过InterceptHandler拦截并重定向标准日志输出\n\n6. **自动化部署**\n   - 难点：简化部署流程，确保版本一致性\n   - 解决方法：配置GitHub Actions工作流，使用SSH远程命令实现代码拉取、依赖安装和服务重启\n\n这个项目综合运用了Web开发、AI模型集成和DevOps实践，构建了一个具备智能对话和OCR功能的后端服务，为富文本编辑器提供AI增强能力。","tags":["AI","Flask","OCR","DevOps"],"categories":["repos"]},{"title":"Film Speak 项目经历简介","url":"/2025/03/13/repos/film-speak/","content":"\n# Film Speak 项目经历简介\n\n## 项目技术栈\n\n### 前端核心技术\n- **React Native (0.76.7)** 与 **Expo (52.0.37)** 构建跨平台移动应用\n- **TypeScript** 提供类型安全\n- **Redux** 与 **Redux Toolkit** 进行状态管理\n- **expo-router** 和 **React Navigation** 系列库处理应用导航\n\n### 多媒体处理\n- **ffmpeg-kit-react-native** 处理视频转换与编辑\n- **microsoft-cognitiveservices-speech-sdk** 实现语音识别与合成\n- **react-native-video** 提供视频播放功能\n- **srt-parser-2** 解析字幕文件\n\n### UI/UX 增强\n- **react-native-paper** 构建现代化UI组件\n- **react-native-reanimated** 和 **lottie-react-native** 实现流畅动画\n- **react-native-haptic-feedback** 提供触觉反馈\n\n### 数据与存储\n- **react-native-mmkv** 高性能键值存储\n- **redux-persist** 状态持久化\n- **expo-file-system** 处理文件操作\n\n### 国际化\n- **i18next** 与 **react-i18next** 支持多语言\n- **react-native-localize** 适配本地化环境\n\n## 技术难点与解决方案\n\n### 1. 视频处理与优化\n**难点**：在移动设备上高效处理视频内容，包括转码、剪辑和格式转换。\n\n**解决方案**：\n- 利用 ffmpeg-kit-react-native 在设备本地进行视频处理\n- 实现分块处理大型视频文件，避免内存溢出\n- 添加后台处理能力，优化用户体验\n\n### 2. 语音识别与字幕生成\n**难点**：准确识别多语言语音并生成同步字幕，处理不同口音和背景噪音。\n\n**解决方案**：\n- 集成微软认知服务语音SDK进行高精度识别\n- 开发自定义字幕同步算法确保视频与文本匹配\n- 实现噪音过滤和语音增强预处理\n\n### 3. 跨平台兼容性\n**难点**：确保在不同设备和操作系统上保持一致的用户体验。\n\n**解决方案**：\n- 使用Expo平台抽象底层差异\n- 实现平台特定代码分离\n- 建立完整的测试流程验证各平台功能\n\n### 4. 性能优化\n**难点**：维持应用在处理大型媒体文件时的流畅性。\n\n**解决方案**：\n- 使用react-native-mmkv替代AsyncStorage提升存储性能\n- 实现虚拟列表和懒加载优化大数据渲染\n- Redux状态设计优化，减少不必要的渲染\n\n### 5. 离线功能支持\n**难点**：在无网络环境下保持核心功能可用。\n\n**解决方案**：\n- 实现本地数据缓存策略\n- 使用redux-persist持久化关键应用状态\n- 开发离线工作模式与在线同步机制\n\n这个项目综合运用了现代移动应用开发技术，解决了多媒体处理、语音识别和跨平台兼容性等复杂技术挑战，提供了流畅的用户体验和强大的功能支持。","tags":["React Native","ffmpeg","Speech Recognition","MMKV","Localization"],"categories":["repos"]},{"title":"Go语言AI聊天机器人项目技术总结","url":"/2025/03/13/repos/aichat-backend/","content":"\n# Go语言AI聊天机器人项目技术总结\n\n## 技术栈\n\n### 后端框架与存储\n- **Go语言**: 使用Go 1.24进行高性能后端开发\n- **Gin框架**: 用于构建RESTful API接口\n- **GORM ORM**: 实现与MySQL的数据交互\n- **MySQL**: 用于存储用户对话历史和会话管理\n\n### AI集成\n- **Azure OpenAI API**: 集成大型语言模型能力\n- **流式响应技术**: 实现AI实时生成内容的流式传输\n\n### 开发辅助工具\n- **Swagger**: 自动生成API文档，简化接口测试\n- **Docker & Docker Compose**: 容器化部署，优化开发和生产环境一致性\n- **godotenv**: 灵活管理环境配置\n\n## 技术难点与解决方法\n\n### 1. 流式数据响应实现\n**难点**: 如何实现AI回复的实时流式传输，避免用户等待完整回复\n**解决方法**:\n- 采用Server-Sent Events (SSE)技术建立长连接\n- 设计回调函数机制处理流式数据块\n- 实现了特殊的HTTP头部设置：`Content-Type: text/event-stream`，保证浏览器正确解析流数据\n\n### 2. 会话上下文管理\n**难点**: 如何维护多轮对话的上下文连贯性\n**解决方法**:\n- 基于UUID设计会话管理系统\n- 使用GORM高效索引与存取历史消息\n- 实现对话历史检索算法，智能加载最近10条历史记录\n\n### 3. Azure OpenAI API集成\n**难点**: 将Azure复杂的AI接口与业务逻辑有效集成\n**解决方法**:\n- 设计AIService抽象层，封装接口复杂性\n- 实现消息格式转换器，统一内部与外部消息格式\n- 构建错误处理机制，增强系统稳定性\n\n### 4. 容器化与环境配置\n**难点**: 确保开发、测试与生产环境的一致性\n**解决方法**:\n- 创建多阶段构建Dockerfile，优化镜像大小\n- 通过Docker Compose管理服务依赖与网络\n- 实现灵活的环境变量配置，支持容器内外统一管理\n\n### 5. 异步通信与错误处理\n**难点**: 处理长时间运行的AI请求可能出现的超时和错误\n**解决方法**:\n- 设计完善的错误处理机制\n- 实现请求上下文管理，支持超时控制\n- 为流式响应设计特殊的错误通知机制\n\n这个项目展示了在Go语言环境下实现AI应用的全栈技能，特别是在性能优化、数据流处理和API设计方面。","tags":["Go","AI","Chatbot","Backend","Docker","Azure"],"categories":["repos"]},{"title":"Python 列表(List) 练习题","url":"/2021/06/01/legacy/python/list/","content":"\n# Python 列表(list) 练习题\n## 一、嘉宾名单\n\n> 如果你可以邀请任何人一起共进晚餐（无论是在世的还是故去的），你会邀请哪些人？请创建一个列表，其中包含至少 3 个你想邀请的人；然后，使用这个列表打印消息，邀请这些人来与你共进晚餐\n\n```python\nguests = [\"Tom\", \"John\", \"Mike\", \"Padma\"]\nfor guest in guests:\n    print(guest + \", 我可以邀请你共进晚餐吗?\")\n```\n\n```shell \nTom, 我可以邀请你共进晚餐吗?\nJohn, 我可以邀请你共进晚餐吗?\nMike, 我可以邀请你共进晚餐吗?\nPadma, 我可以邀请你共进晚餐吗?\n```\n\n## 二、修改嘉宾名单\n> 你刚得知有位嘉宾无法赴约，因此需要另外邀请一位嘉宾。以完成练习 1 时编写的程序为基础，在程序末尾添加一条`print`语句，指出哪位嘉宾无法赴约。修改嘉宾名单，将无法赴约的嘉宾的姓名替换为新邀请的嘉宾的姓名。再次打印一系列消息，向名单中的每位嘉宾发出邀请\n\n```python\nprint(guests[2] + \"不能一起吃饭!\" + \"\\n\")\nguests[2] = 'Bob'\nfor guest in guests:\n    print(guest + \", 我可以邀请你共进晚餐吗?\")\n```\n\n```shell\nMike不能一起吃饭!\n\nTom, 我可以邀请你共进晚餐吗?\nJohn, 我可以邀请你共进晚餐吗?\nBob, 我可以邀请你共进晚餐吗?\nPadma, 我可以邀请你共进晚餐吗?\n```\n\n## 三、添加嘉宾\n> 你刚找到了一个更大的餐桌，可容纳更多的嘉宾。请想想你还想邀请哪三位嘉宾。以完成练习 1 或练习 2 时编写的程序为基础，在程序末尾添加一条`print`语句，指出你找到了一个更大的餐桌。使用`insert()`将一位新嘉宾添加到名单开头。使用`insert()`将另一位新嘉宾添加到名单中间。使用`append()`将最后一位新嘉宾添加到名单末尾。打印一系列消息，向名单中的每位嘉宾发出邀请\n\n```python\nprint(\"我找到了一个更大的餐桌!\" + \"\\n\")\nguests.insert(0, 'zhangsan')\nguests.insert(3, 'lisi')\nguests.append('wangwu')\nfor guest in guests:\n    print(guest + \", 我可以邀请你共进晚餐吗?\")\n```\n\n```shell\n我找到了一个更大的餐桌!\n\nzhangsan, 我可以邀请你共进晚餐吗?\nTom, 我可以邀请你共进晚餐吗?\nJohn, 我可以邀请你共进晚餐吗?\nlisi, 我可以邀请你共进晚餐吗?\nBob, 我可以邀请你共进晚餐吗?\nPadma, 我可以邀请你共进晚餐吗?\nwangwu, 我可以邀请你共进晚餐吗?\n```\n\n## 四、缩减名单\n你刚得知新购买的餐桌无法及时送达，因此只能邀请两位嘉宾。\n> 以完成练习 3 时编写的程序为基础，在程序末尾添加一行代码，打印一条你只能邀请两位嘉宾共进晚餐的消息。使用`pop()`不断地删除名单中的嘉宾，直到只有两位嘉宾为止。每次从名单中弹出一位嘉宾时，都打印一条消息，让该嘉宾知悉你很抱歉，无法邀请他来共进晚餐。对于余下的两位嘉宾中的每一位，都打印一条消息，指出他依然在受邀人之列。使用`del()`将最后两位嘉宾从名单中删除，让名单变成空的。打印该名单，核实程序结束时名单确实是空的\n\n```python\nprint(\"sorry,我只能邀请两位嘉宾共进晚餐!\" + \"\\n\")\nwhile len(guests) > 2:\n    honored = guests.pop()\n    print(honored + \",我很抱歉,我不能邀请你一起共进晚餐!\")\nprint(\"------------\")\nfor guest in guests:\n    print(guest + \", 我仍然希望你能和我一起吃饭!\")\ndel guests[0]\ndel guests[0]\nprint(guests)\n```\n\n```shell\nsorry,我只能邀请两位嘉宾共进晚餐!\n\nwangwu,我很抱歉,我不能邀请你一起共进晚餐!\nPadma,我很抱歉,我不能邀请你一起共进晚餐!\nBob,我很抱歉,我不能邀请你一起共进晚餐!\nlisi,我很抱歉,我不能邀请你一起共进晚餐!\nJohn,我很抱歉,我不能邀请你一起共进晚餐!\n------------\nzhangsan, 我仍然希望你能和我一起吃饭!\nTom, 我仍然希望你能和我一起吃饭!\n[]\n```\n\n## 五、晚餐嘉宾\n> 使用`len()`打印一条消息，指出你邀请了多少位嘉宾来与你共进晚餐\n\n```python\nguests = [\"Tom\", \"John\", \"Mike\", \"Padma\"]\nprint(\"我一共邀请了\" + str(len(guests)) + \"位嘉宾\")\n```\n\n```shell\n我一共邀请了4位嘉宾\n```","tags":["Python","Study"],"categories":["legacy","python"]},{"title":"Python 元组(Tuple) 练习题","url":"/2021/06/01/legacy/python/tuple/","content":"\n# Python 元组(Tuple) 练习题\n\n## 1. 将一个给定的整型元组：`tuple(range(1, 7))`倒序输出\n\n```python\nnums = tuple(range(1, 7))\n\nprint(nums)\n# (1, 2, 3, 4, 5, 6)\n```\n\n```python\nlist_nums: list = sorted(nums, reverse=True)\ntuple_nums = tuple(list_nums)\n\nprint(list_nums)\nprint(tuple_nums)\n```\n\n```shell\n[6, 5, 4, 3, 2, 1]\n(6, 5, 4, 3, 2, 1)\n```\n\n## 2. 请问以下变量哪些是 `tuple` 类型：  \n> A. a = ()  \n> B. b = (1)  \n> C. c = [2]  \n> D. d = (3,)  \n> E. e = (4, 5, 6)\n\n```shell\nA, D, E\n```\n","tags":["Python","Study"],"categories":["legacy","python"]},{"title":"语义化版本 2.0.0","url":"/2020/03/10/legacy/versioning/","content":"\n## 摘要\n\n版本格式：主版本号.次版本号.修订号，版本号递增规则如下：\n\n1.  主版本号：当你做了不兼容的 API 修改，\n2.  次版本号：当你做了向下兼容的功能性新增，\n3.  修订号：当你做了向下兼容的问题修正。\n\n先行版本号及版本编译元数据可以加到\"主版本号.次版本号.修订号\"的后面，作为延伸。\n\n## 简介\n\n在软件管理的领域里存在着被称作\"依赖地狱\"的死亡之谷，系统规模越大，加入的包越多，你就越有可能在未来的某一天发现自己已深陷绝望之中。\n\n在依赖高的系统中发布新版本包可能很快会成为噩梦。如果依赖关系过高，可能面临版本控制被锁死的风险（必须对每一个依赖包改版才能完成某次升级）。而如果依赖关系过于松散，又将无法避免版本的混乱（假设兼容于未来的多个版本已超出了合理数量）。当你专案的进展因为版本依赖被锁死或版本混乱变得不够简便和可靠，就意味着你正处于依赖地狱之中。\n\n作为这个问题的解决方案之一，我提议用一组简单的规则及条件来约束版本号的配置和增长。这些规则是根据（但不局限于）已经被各种封闭、开放源码软件所广泛使用的惯例所设计。为了让这套理论运作，你必须先有定义好的公共\nAPI 。这可以透过文件定义或代码强制要求来实现。无论如何，这套 API\n的清楚明了是十分重要的。一旦你定义了公共\nAPI，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：X.Y.Z\n（主版本号.次版本号.修订号）修复问题但不影响API 时，递增修订号；API\n保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。\n\n我称这套系统为\"语义化的版本控制\"，在这套约定下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。\n\n## 语义化版本控制规范（SemVer）\n\n以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD\nNOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119\n的叙述解读。（译注：为了保持语句顺畅，\n以下文件遇到的关键词将依照整句语义进行翻译，在此先不进行个别翻译。）\n\n1.  使用语义化版本控制的软件必须（MUST）定义公共 API。该 API\n    可以在代码中被定义或出现于严谨的文件内。无论何种形式都应该力求精确且完整。\n\n2.  标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z\n    为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y\n    是次版本号、而 Z\n    为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -\\> 1.10.0\n    -\\> 1.11.0。\n\n3.  标记版本号的软件发行后，禁止（MUST\n    NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。\n\n4.  主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共\n    API 不应该被视为稳定版。\n\n5.  1.0.0 的版本号用于界定公共 API\n    的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。\n\n6.  修订号 Z（x.y.Z `|` x \\>\n    0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。\n\n7.  次版本号 Y（x.Y.z `|` x \\>\n    0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API\n    的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。\n\n8.  主版本号 X（X.y.z `|` x \\>\n    0）必须（MUST）在有任何不兼容的修改被加入公共 API\n    时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。\n\n9.  先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由\n    ASCII 字母数字和连接号 \\[0-9A-Za-z-\\] 组成，且禁止（MUST\n    NOT）留白。数字型的标识符禁止（MUST\n    NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。\n\n10. 版本编译元数据可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由\n    ASCII 字母数字和连接号 \\[0-9A-Za-z-\\] 组成，且禁止（MUST\n    NOT）留白。当判断版本的优先层级时，版本编译元数据可（SHOULD）被忽略。因此当两个版本只有在版本编译元数据有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。\n\n11. 版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译元数据不在这份比较的列表中）。由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较，例如：1.0.0\n    \\< 2.0.0 \\< 2.1.0 \\<\n    2.1.1。当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha\n    \\<\n    1.0.0。有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：只有数字的标识符以数值高低比较，有字母或连接号时则逐字以\n    ASCII\n    的排序来比较。数字的标识符比非数字的标识符优先层级低。若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。范例：1.0.0-alpha\n    \\< 1.0.0-alpha.1 \\< 1.0.0-alpha.beta \\< 1.0.0-beta \\< 1.0.0-beta.2\n    \\< 1.0.0-beta.11 \\< 1.0.0-rc.1 \\< 1.0.0。\n\n## 为什么要使用语义化的版本控制？\n\n这并不是一个新的或者革命性的想法。实际上，你可能已经在做一些近似的事情了。问题在于只是\"近似\"还不够。如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。\n\n举个简单的例子就可以展示语义化的版本控制如何让依赖地狱成为过去。假设有个名为\"救火车\"的函式库，它需要另一个名为\"梯子\"并已经有使用语义化版本控制的包。当救火车创建时，梯子的版本号为\n3.1.0。因为救火车使用了一些版本 3.1.0 所新增的功能，\n你可以放心地指定依赖于梯子的版本号大等于 3.1.0 但小于\n4.0.0。这样，当梯子版本 3.1.1 和 3.2.0\n发布时，你可以将直接它们纳入你的包管理系统，因为它们能与原有依赖的软件兼容。\n\n作为一位负责任的开发者，你理当确保每次包升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级包，而无需推出新的依赖包，节省你的时间及烦恼。\n\n如果你对此认同，希望立即开始使用语义化版本控制，你只需声明你的函式库正在使用它并遵循这些规则就可以了。请在你的\nREADME 文件中保留此页连结，让别人也知道这些规则并从中受益。\n\n## FAQ\n\n### 在 0.y.z 初始开发阶段，我该如何进行版本控制？\n\n最简单的做法是以 0.1.0\n作为你的初始化开发版本，并在后续的每次发行时递增次版本号。\n\n### 如何判断发布 1.0.0 版本的时机？\n\n当你的软件被用于正式环境，它应该已经达到了 1.0.0\n版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0\n版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。\n\n### 这不会阻碍快速开发和迭代吗？\n\n主版本号为零的时候就是为了做快速开发。如果你每天都在改变\nAPI，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。\n\n### 对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？\n\n这是开发的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价可能是巨大的。要递增主版本号来发行不兼容的改版，意味着你必须为这些改变所带来的影响深思熟虑，并且评估所涉及的成本及效益比。\n\n### 为整个公共 API 写文件太费事了！\n\n为供他人使用的软件编写适当的文件，是你作为一名专业开发者应尽的职责。保持专案高效一个非常重要的部份是掌控软件的复杂度，如果没有人知道如何使用你的软件或不知道哪些函数的调用是可靠的，要掌控复杂度会是困难的。长远来看，使用语义化版本控制以及对于公共\nAPI 有良好规范的坚持，可以让每个人及每件事都运行顺畅。\n\n### 万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？\n\n一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文件中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。\n\n### 如果我更新了自己的依赖但没有改变公共 API 该怎么办？\n\n由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的包有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我经常会预期伴随着更多的代码，这显然会是一个次版本号级别的递增。\n\n### 如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？\n\n自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住，语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。\n\n### 我该如何处理即将弃用的功能？\n\n弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部份公共 API 时，你应该做两件事：（1）更新你的文件让使用者知道这个改变，（2）在适当的时机将弃用的功能透过新的次版本号发布。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用信息，这样使用者才能平顺地转移到新版 API。\n\n### 语义化版本对于版本的字串长度是否有限制呢？\n\n没有，请自行做适当的判断。举例来说，长到 255 个字元的版本已过度夸张。再者，特定的系统对于字串长度可能会有他们自己的限制。\n","tags":["coding","developer"],"categories":["legacy"]},{"title":"复旦大学简介","url":"/2020/03/10/legacy/fudan-intro/","content":"\n## 简介\n\n复旦大学( FuDan University)简称复旦。复旦大学是中国人自主创办的第一所高等学府，学校直属中华人民共和国教育部领导，是教育部与上海市共建的全国重点大学，中国首批7所\"211工程\"、首批9所\"985工程\"重点高校之一，也是首批\"珠峰计划\"、\"111计划\"重点建设的研究型大学，同时亦是长三角高校合作联盟、金砖国家大学联盟和中国C9联盟成员。\n\n## 历史\n\n复旦大学创建于1905年，原名**复旦公学**，是中国第一所由国人通过民间集资、自主创办的高等学校。由于不满法国教会对震旦学院的干涉，创校人马相伯率学校中国师生复课，由于右任提议，从《尚书大传·虞夏传》\"**日月光华，旦复旦兮**\"中撷取\"复旦\"二字命名，改校名为\"复旦公学\"，示意不忘\"震旦\"之旧，更含恢复中华、兴学救国之意。复旦大学各医学院系、研究单位以及各家附属医院的前身是上海医科大学及其附属医院。上海医科大学创建于1927年，是中国人自主创办的第一所高等医学院校，由中国近代著名医学教育家颜福庆创立。\n\n新生的复旦历经危难，几度陷入解体的困境；抗战时期，学校辗转江西再到重庆艰难复校。但学校师生同心，终使复旦从一所大学预备学校发展成一所知名的国立大学。1952年全国院系调整中，名师云集新复旦，学校实力倍增、迅速崛起；改革开放后，复旦把握机遇，逐渐从一所文理类高校发展成为一所**多科性研究型综合大学**；2000年，复旦和上海医科大学合并，开始了\"**建设世界一流大学**\"的进程。\n\n### 复旦公学时期\n\n![Fudan-building-Gate](https://i.loli.net/2019/08/18/opD8fKLMWSiXkdz.jpg)\n\n仿古木制校门，还原1921年大学部迁址江湾时正门之原貌，现已作景观用途，并未设立于主干道路之上。\n\n复旦公学的创立，与震旦学院有不少渊源，取名\"复旦\"，既有恢复震旦之意，又有自强不息之意。\n\n1903年马相伯先生创建了震旦学院；1905年震旦学院因外籍传教士南从周篡夺校政发生学潮，130名学生愤然离校，拥戴马相伯另立新校；退学学生公推于右任、叶仲裕等7人为干事，商议新校创建办法。1905年，马相伯、叶仲裕等邀请热心教育事业的严复、张謇、熊希龄等28人为校董，筹集复旦建校资金。两江总督周馥拨银1万两，并借吴淞提督衙门为临时校舍。\n\n1905年6月29日（农历五月廿七），原震旦学院教师于《时报》登载《震旦学院退学师生公白》，是为\"复旦\"校名之始。\n\n是年中秋节翌日（公历9月14日），民办官助的复旦公学正式开学，依照清政府高等学堂章程，将近二百学生编为八班，前四班为高等科（大学预科），后四班为预班（中学部）。\n\n1911年12月，吴淞校舍被光复军占用，复旦一度迁校无锡惠山，月余返沪。\n\n1912年5月，暂借爱而近路(今安庆路)开学。9月，迁入李公祠。此后，马相伯去北京任要职，不能亲理校务。学校实际负责人为教务长胡敦复、庶务长叶藻庭。12月，学校发生风潮。为整顿校务，孙中山、王宠惠、陈英士、程德全、唐绍仪、于右任等组成校董会，重订章程，筹措经费，并推王宠惠任董事长，李登辉任校长。\n\n1913年3月1日，复旦重新开学。不久，\"二次革命\"爆发，校董多逃亡海外，学校经费来源断绝。李登辉采取提高学费、扩大招生人数的办法，在校生由九十余人增至三百余人，学费自一百二十元增至一百六十元，藉以挹注，使复旦度过难关。同时，聘请硕学之士担任讲习，增加学科，扩充体制，校务始克发展。\n\n从1912年至1916年，复旦公学共培养大学预科毕业生15人，中学毕业生150人。\n\n1915年，学校在江湾购地，以建校舍、恢弘规模。从此，建设复旦、办与欧美并驾齐驱的大学成为李登辉毕生的事业。复旦的发展和他关系极大，如果说马相伯是复旦的缔造者，那么李登辉则是复旦重要的振兴者。\n\n### 进入新世纪\n\n2000年，复旦大学与上海医科大学合并，成立新的复旦大学，综合实力进一步增强，优势学科从\"文理并进\"发展成为文理医\"三足鼎立\"的新格局。上海医科大学与老复旦大学的合并，拓宽了复旦的学科结构，为世界一流综合性大学的发展目标奠定了基础。但在合校初期，上海医科大学各医学院系和附属医院被调整为由校方统一管理，这一管理体制后来被证明不符合医学教育、临床和科研的实际，影响了上医的发展。\n\n2005年，复旦大学建校100周年，张江校区、江湾新校区先后建成投入使用。同年复旦学院作为本科一年级新生学院成立，作为学校实施通识教育的教学、研究和管理机构。\n\n2012年，新的复旦学院成立，复旦学院升格为复旦大学的本科生院。同年，新的上海医学院成立，作为学校党政的派出机关，代表学校统一管理各医学院系和附属医院。\n\n## 传统与文化\n\n### 校训\n\n复旦大学的校训是\"**博学而笃志，切问而近思**\"，出自《论语·子张第十九》，复旦的校训并非在学校诞生之时就确定的。在复旦建校十年（1915年）之际，当时的校长李登辉先生仿效美国名校制度，制定校训、校徽，于是才有了校训的产生。\n\n### 精神\n\n\"复旦精神\"是**团结、服务、牺牲**，由老校长李登辉总结归纳。1947年7月，他对毕业生说：\"服务、牺牲、团结，是复旦的精神，更是你们的责任！\"。\n\n此外，学校百年校庆时提出\"**爱国奉献、学术独立、海纳百川、追求卓越**\"为新时期复旦精神；也有很多学生认同\"自由而无用\"------即思想与学术、甚至生活观念，能在无边的时空中恣意游走，以及对身边现实功利的有意疏离------为复旦的灵魂。\n\n### 校花\n\n复旦大学的校花是**白玉兰**。因其绽于春寒料峭时，先开花后生叶，花开时皎洁如白玉，得誉\"**花中君子**\"，故以此为校花。\n\n1913年3月，复旦公学刚刚从吴淞迁入徐家汇的李公祠，庭院中有数株白玉兰树正在绽放，师生认为白玉兰是\"花中君子\"，私下定为校花。\n\n1947年，李登辉校长在复旦同学会（即校友会）年会上正式提议白玉兰为复旦校花，得到了与会校友的热烈鼓掌而获通过。\n\n### 校歌\n\n现行校歌（老校歌）创作于1925年，于复旦2005年百年校庆时正式恢复校歌地位。由刘大白作词、丰子恺作曲。\n\n>复旦复旦旦复旦，巍巍学府文章焕，  \n>学术独立思想自由，政罗教网无羁绊；  \n>无羁绊，前程远，向前、向前，向前进展！  \n>复旦复旦旦复旦，日月光华同灿烂！  \n>复旦复旦旦复旦，师生一德精神贯，  \n>巩固学校维护国家，先忧后乐交相勉；  \n>交相勉，前程远，向前、向前，向前进展！  \n>复旦复旦旦复旦，日月光华同灿烂！  \n>复旦复旦旦复旦，沪滨屹立东南冠，  \n>作育国士恢廓学风，震欧铄美声名满。  \n>声名满，前程远，向前、向前，向前进展！  \n>复旦复旦旦复旦，日月光华同灿烂！  \n\n## 学术研究\n\n### 科研机构\n\n　　\n截至2014年，复旦大学有国家重点实验室5个、国家教育部重点实验室12个、国家卫生部重点实验室9个、总后卫生部重点实验室1个、上海市重点实验室7个、世界银行贷款重点实验室2个；国家教育部工程研究中心4个、上海市工程技术研究中心2个；8个国家教育部人文社会科学重点研究基地、4个上海市社会科学创新研究基地；\"985工程\"科技创新平台5个、\"985工程\"哲学社会科学创新基地7个。\n\n### 科研成果\n\n　　\n复旦大学诞生了中国第一台质子静电加速器、第一台电子模拟计算机和第一个ALGOL-60编译器，第一台X.25分组交换机，第一套因特网监控装备、第一批真正意义上的数字电子计算机。\n\n截至2014年，复旦大学有15个学科领域进入ESI全球前1%，数量位居全国第二，理工科有3个学科进入了世界前100名。根据2007年资料显示：该校共承担了国家重点基础研究发展规划项目（973项目）8项、863课题60项，国家自然科学基金重大项目多项，国家自然科学基金重点项目38项。\n\n## 四大校区\n\n经过多年的建设和发展，复旦大学已经形成\"一体两翼\"的校园格局：即以邯郸校区、江湾新校区为一体，以枫林校区、张江校区为两翼。截至12年底，学校共有土地244.32万平方米，合约3813亩。\n\n### 邯郸路校区\n\n　　邯郸路校区是复旦最主要的校区，目前是大部分院系的所在地。其正门位于邯郸路220号，近五角场。占地922297平方米，合1383亩。未来，邯郸校区的功能定位将被调整为以人文社会科学院系和本科生教学为主。\n\n### 枫林校区\n\n　　枫林校区位于徐汇区，是原上海医科大学校址。占地192123平方米，合288亩，位于医学院路138号。是基础医学院、公共卫生学院、护理学院的所在地。枫林校区的功能定位是医学学科相关院系和本科生教学。\n\n### 张江校区\n\n　　张江校区坐落于浦东新区张江高科技园区。占地228176平方米，合342亩，位于张衡路825号。是微电子学院、计算机科学技术学院、软件学院、药学院的所在地。张江校区的定位是以产学研前沿相关的学科为主。\n\n### 江湾校区\n\n　　江湾新校区是复旦面积最大的校区，位于淞沪路2005号，杨浦区西北角、新江湾城的西北部，规划总体面积达1500亩。校区距江湾城市副中心约1.5公里，距复旦大学邯郸路校区约3.5公里。法学院位于江湾新校区，生命科学学院即将搬入江湾校区。未来规划的定位是以理科部分和工科院系及科研机构为主，生命科学大楼即将建成，数学、物理、化学和环境生态大楼也已列入建设规划。\n","tags":["study","university","Fudan","Shanghai","education","history"],"categories":["legacy"]}]